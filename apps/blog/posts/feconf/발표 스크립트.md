# 오픈소스 밥상차리기 발표 스크립트

## 슬라이드 1: 표지

안녕하세요. 오늘 "오픈소스 밥상차리기 - 환경설정부터 디버깅까지"라는 주제로 발표하게 된 [이름]입니다.

오픈소스 코드를 읽고 기여하는 실용적인 가이드에 대해 이야기해보겠습니다. 개발자로서 성장하기 위해 반드시 거쳐야 할 과정인 오픈소스 기여에 대해 실전 경험을 바탕으로
말씀드리겠습니다.

## 슬라이드 2: 목차

오늘 발표는 크게 6가지 주제로 구성되어 있습니다.

먼저 제가 직접 기여한 오픈소스 프로젝트들의 성과를 소개하고, 오픈소스 기여가 개발자에게 가져다주는 가치에 대해 이야기하겠습니다.

그 다음으로는 실제 코드 읽기의 가치와 문제 해결 능력 향상 방법을 다루고, 환경 구축 가이드와 AI 도구 활용 전략까지 실무에 바로 적용할 수 있는 내용들을 준비했습니다.

## 슬라이드 3: 발표자 소개 및 성과 현황

제가 지금까지 기여한 주요 오픈소스 프로젝트들을 소개드리겠습니다.

첫 번째로 Mantine 프로젝트에 23회 도전해서 20회 머지 성공, 87%의 성공률을 기록했습니다. 주로 UI 컴포넌트 라이브러리 개선에 기여했습니다.

React Hook Form에는 2회 도전해서 2회 모두 성공, 100% 성공률을 달성했습니다. 폼 상태 관리 라이브러리의 핵심 기능 개선에 참여했습니다.

Next.js에는 3회 도전해서 1회 머지 성공, 33% 성공률을 기록했습니다. 프레임워크 복잡도가 높아서 난이도가 있었지만 좋은 학습 경험이 되었습니다.

## 슬라이드 4: 오픈소스 기여를 계속하는 이유

오픈소스 기여를 계속하는 이유는 크게 두 가지입니다.

첫 번째는 매일 사용하는 도구의 동작 원리를 이해할 수 있다는 점입니다. "왜 계속 하나요?"라는 질문에 대한 답으로, 매일 사용하는 라이브러리의 내부 구조를 파악하고 코드를 직접
보면서 얻는 깊은 이해가 있습니다.

예를 들어, React Hook Form의 useWatch 함수가 어떻게 동작할 때 코드를 읽어보니 "아 이래서 이렇게 동작하는구나"라고 깨달을 수 있었습니다.

두 번째는 문서로 해결되지 않는 문제를 직접 해결할 수 있다는 점입니다. 공식 문서만으로는 해결되지 않는 문제들을 직접 코드를 수정하여 버그 해결 가능성을 높이고, 이 과정에서
얻는 자신감이 "라이브러리 사용자"에서 "오픈소스 생태계의 일부"로 성장할 수 있게 해줍니다.

## 슬라이드 5-6: 오픈소스 코드 읽기로 얻는 것들

오픈소스 코드 읽기를 통해 얻을 수 있는 것들을 세 가지 관점에서 말씀드리겠습니다.

**첫 번째, 내부 동작 원리 이해**
라이브러리의 숨겨진 기능과 최적화 패턴을 학습할 수 있습니다. 예를 들어 React hook form 라이브러리에서 `useWatch` 의 오버라이딩을 파악하거나,
createFormController.ts를 발견할 수 있습니다.

**두 번째, 문서에 없는 내용 파악**
공식 문서에 나오지 않는 고급 사용법이나 에러 처리 방식을 이해할 수 있고, 내부 API 활용 방법을 배울 수 있습니다.

**세 번째, 디버깅 능력 향상**
문제 상황 재현 방법을 익히고, 코드 추적 기술을 향상시킬 수 있으며, 디버깅 도구 활용법과 로깅 전략을 학습할 수 있습니다.

그리고 또 한 가지 중요한 점은, 실무에서 바로 써먹을 수 있는 고급 기술들도 자연스럽게 배우게 된다는 거예요.

**모노레포 구성하는 방법들**
예를 들어서 Lerna, Nx, Turborepo 같은 최신 모노레포 도구들을 어떻게 쓰는지 볼 수 있고요. 패키지끼리 의존성을 어떻게 관리하는지, 버전은 어떻게 올리는지도 배우게 돼요. 특히 공유 라이브러리랑 각각의 앱들 사이에서 빌드를 어떻게 효율적으로 돌리는지, 코드 중복을 어떻게 없애는지 같은 실전 노하우들을 얻을 수 있어요.

**컴포넌트 테스트는 어떻게 짜야 하는지**
실제로 오픈소스 프로젝트들 보면, Testing Library를 어떻게 써서 사용자 관점에서 테스트를 작성하는지 정말 잘 나와 있어요. MSW로 API를 어떻게 모킹하는지, 컴포넌트 단위 테스트랑 통합 테스트의 밸런스를 어떻게 맞추는지도 보게 되고요. 테스트 유틸리티 함수들이나 커스텀 렌더러 패턴들, 그리고 스냅샷 테스트까지 실제로 어떻게 활용하는지 배울 수 있어서 정말 도움이 많이 돼요.

**컴포넌트를 어떻게 설계해야 하는지에 대한 인사이트**
이게 정말 값진 부분인데요, 컴포지션 패턴이나 렌더 프롭을 실제로 어떻게 쓰는지 볼 수 있고, 타입스크립트 제네릭으로 재사용 가능한 컴포넌트를 어떻게 만드는지도 배워요. 특히 Radix UI나 Headless UI 스타일의 컴파운드 컴포넌트 패턴을 보면 "아, 이렇게 만드는구나!" 하고 깨닫게 되거든요. props drilling 문제를 Context로 어떻게 해결하는지, 접근성까지 고려한 WAI-ARIA 구현은 어떻게 하는지까지 실제 코드로 볼 수 있어서 정말 좋아요.

## 슬라이드 7: 문제 해결 능력 향상

오픈소스 코드를 읽고 기여하면서 문제 해결 능력이 크게 향상됩니다.

실제로 제가 겪었던 Next.js 버그 추적 과정을 말씀드릴게요.

**이슈 발견:** 어느 날 Script 컴포넌트를 쓰는데, HTML을 보니까 class가 아니라 className으로 그대로 렌더링되는 거예요. "어? 이상하네?" 하면서 시작됐죠.

**범위 좁히기:** 처음엔 "모든 Script 컴포넌트가 문제인가?" 했는데, 알고 보니 `strategy="beforeInInteractive"` 옵션을 쓸 때만 발생하더라고요. "아, 특정 조건에서만 생기는 버그구나!"

**코드 파헤치기:** 그래서 Next.js 코드를 들여다보기 시작했어요. 다른 컴포넌트들은 어떻게 하는지 보니까, setAttributesFromProps라는 함수를 써서 className을 class로 바꿔주더라고요. "아하! 얘들은 이렇게 하는구나!"

**범인 찾기:** 그런데 beforeInInteractive 전략을 쓰는 부분만 이 변환 과정이 빠져있는 거였어요. "바로 여기네!" 하고 찾아냈죠.

이런 식으로 단서를 하나씩 따라가면서 문제의 근본 원인을 찾아내는 과정이 정말 스릴 넘치더라고요. 마치 탐정이 된 기분이었어요!

## 슬라이드 8: 오픈소스 기여 후 달라진 것들

오픈소스에 기여한 후 4가지 주요 변화가 있었습니다.

**마인드셋 변화**
"내가 찾은 순 간가?"가 아니라 "코드를 확인해보자"라는 자세로 바뀌었습니다. 문제 원인을 찾는 자신감이 생겼고, 라이브러리를 두려워하지 않게 되었습니다.

**업무 효과**
팀에서 "라이브러리 전문가"라는 역할을 담당하게 되었고, 동료들의 질문에 답할 수 있는 기여자 역량을 확보했습니다. 기술적 의사결정에 기여할 수 있게 되었고, 팀 내 지식 공유
활성화에 도움이 되었습니다.

**디버깅 시간 단축**
디버깅 시간이 크게 단축되었고, 문제 발생 시 빠른 원인 파악이 가능해졌습니다. 코드 흐름 이해로 효율적 해결책을 찾을 수 있고, 반복적인 시행착오를 감소시킬 수 있었습니다.

**글로벌 임팩트**
수백만 명의 개발자들이 내가 수정한 버그의 혜택을 누리게 되었고, 오픈소스 환경에 기여하며 전 세계 개발자 커뮤니티의 일원이 될 수 있었습니다.

## 슬라이드 9: 실제 사례 분석

실제 기여 사례들을 통해 구체적인 문제 해결 과정을 보여드리겠습니다.

**환경 구축을 대중하고 시작한 실패**
첫 번째 실패: Next.js 환경 구축 미흡으로 인한 테스터가 제대로 실행하는 상황이 발생했습니다. 원인 파악이 불가능한 상태였고, 결국 처음부터 다시 시작해야 했습니다.

**공식 문서를 안 읽고 "버그"라고 착각**
의도된 동작을 버그로 오해하여 메인테이너에게 "이건 예상된 동작입니다"라는 답변을 받았습니다. 문서를 제대로 읽지 않은 실수였습니다.

**이슈 확인과 문서 정독의 중요성**
이슈를 제출하기 전에 문서 정독하기, 기존 이슈 검색으로 중복 확인, 테스트 코드로 버그 재현 확인, 의도된 동작인지 확인 필요성을 깨달았습니다.

## 슬라이드 10: 프로젝트 선택 전략

성공적인 오픈소스 기여를 위한 프로젝트 선택 전략을 말씀드리겠습니다.

**쉬운 프로젝트 (Mantine, React Hook Form)**

- 문서화가 잘 되어 있음
- CONTRIBUTING.md가 친절함
- 커뮤니티가 활발함
- 메인테이너 리뷰가 빠름
- 평소 만났던 코드와 별로 다르지 않음

**어려운 프로젝트 (Next.js)**

- 거대한 코드베이스
- 복잡한 모노레포 구조
- 높은 진입 장벽

처음 시작하실 때는 쉬운 프로젝트부터 시작하시는 것을 추천드립니다.

## 슬라이드 11-12: 환경 구축 체크리스트

환경 구축의 두 번째 단계는 프로젝트의 기본 정보를 정확히 파악하는 것입니다.

**CONTRIBUTING.md 정독**
git clone 후 가장 먼저 할 일은 cat CONTRIBUTING.md | head -50으로 프로젝트마다 다른 규칙 확인, 환경 구축 방법 파악, 특별한 규칙 이해, 시간
투자 대비 효율적입니다.

**환경 구축 방법**
필요한 도구 및 버전 확인, 의존성 설치 방법, 빌드 프로세스 이해, 테스트 실행 방법, 개발 서버 실행 방법, 로컬 환경에서 검증 방법을 순서대로 진행합니다.

**기본 정보 파악과 Node 버전, 패키지 매니저, 스크립트 탐색**에 관한 세부 내용도 체크리스트에 포함되어 있습니다.

특히 환경 구축의 두 번째 중요한 단계는 프로젝트의 기본 정보를 정확히 파악하고, package.json 파일에서 찾을 수 있으며, 이를 통해 개발 환경을 올바르게 설정할 수
있습니다.

## 슬라이드 13: 환경 구축 체크리스트 (3) - 의존성 설치

의존성 설치 과정에서는 4가지 핵심 단계를 거쳐야 합니다.

**1단계: Node 버전**
프로젝트 지정 버전 준수가 중요합니다.

**2단계: 패키지 설치**
패키지 매니저 확인 후 적절한 명령어 사용이 필요합니다. pnpm install (pnpm-lock.yaml), yarn install (yarn.lock), npm install
순서로 진행합니다.

**3단계: 빌드 실행**
모노레포는 빌드 순서가 중요합니다. pnpm build 또는 npm run build를 실행합니다.

**4단계: 개발 서버**
개발 서버 실행으로 변경사항 확인이 가능합니다. pnpm dev 또는 npm run dev를 실행하고, 로컬 환경에서 테스트를 진행하며, 브라우저 개발자 도구를 활용합니다.

## 슬라이드 14: 디버깅 환경 구성

효과적인 디버깅을 위한 환경 구성 방법을 소개합니다.

**테스트 환경 구성**
테스트 코드는 오픈소스 기여의 핵심입니다. 기존 테스트 파일 위치 파악하기, 테스트 프레임워크 확인 (Jest, Vitest 등), 테스트 유틸리티 함수 활용 방법 학습이
필요합니다.

**특정 테스트만 실행하기**
전체 테스트 실행은 시간이 오래 걸리므로, 특정 파일만 테스트: `pnpm test -- --testPathPattern="useWatch"`, watch 모드 활용:
`pnpm test:watch`를 사용합니다.

**Console 디버깅**
가장 간단한 디버깅 방법으로 `console.log('useWatch called with:', props);`, 객체 구조 확인:
`console.dir(obj, {depth: null});`을 활용할 수 있습니다.

**Debugger 활용**과 **조건부 로깅**도 중요한 디버깅 도구입니다.

## 슬라이드 15: AI와 함께 코드베이스 정복하기

현대 개발에서 AI 도구는 필수가 되었습니다. 특히 오픈소스 기여에서 AI를 활용하는 방법을 소개하겠습니다.

**발표 스크립트**
거대한 오픈소스 코드베이스를 혼자 이해하기는 어렵습니다. AI 도구를 활용하면 10배 빠르게 코드베이스에 익숙해질 수 있습니다. 특히 Claude Code와 같은 도구는 전체
코드베이스를 학습하여 정확한 답변을 제공합니다.

**Claude Code /init 활용법**
프로젝트 루트에서 Claude Code를 실행하고 전체 코드베이스를 학습시키는 방법:

1. claude 명령어로 실행
2. /init 명령어로 코드베이스 학습
3. 원하는 질문 입력

**실제 질문 예시와 AI 도구 활용 팁**

- "이 프로젝트에서 useWatch 함수는 어디에 정의되어 있나요?"
- "Button 컴포넌트의 테스트 코드는 어떻게 작성되어 있나요?"
- "이 이슈 #1234와 관련된 코드는 어디에 있나요?"
- "이 함수가 어떻게 동작하는지 설명해주세요."

## 슬라이드 16: AI 도구 활용 전략

AI 도구를 효과적으로 활용하기 위한 3가지 전략을 소개합니다.

**Claude Code**
코드베이스 분석에 특화된 도구로, 파일 위치 찾기 기능이 탁월하며, 코드 이해 및 설명 능력이 우수합니다.

**Cursor**
IDE에 통합된 AI 코딩 도우미로, 전체 파일 컨텍스트 기반 정확한 수정 제안을 받을 수 있고, 에러 수정 및 리팩토링 자동화가 가능합니다.

**조합 활용법**
Claude Code로 코드베이스 이해하고, Copilot으로 테스트 코드 생성하며, AI 없이 2시간 걸릴 일을 10분에 해결할 수 있습니다.

## 슬라이드 17: 실전 코드 기여 전략

실제 코드 기여를 위한 체계적인 접근 방법을 소개합니다.

**1단계: 이슈 탐색**
GitHub 이슈 페이지에서 관련 이슈를 찾아보세요. 이슈 댓글들을 꼼꼼히 읽어서 전체 맥락을 파악하고, 아직 해결되지 않은 이슈를 우선적으로 선택하세요. 그리고 무엇보다 자신이 관심 있어 하는 분야의 이슈를 찾는 게 중요해요.

**2단계: 테스트 작성 - 이게 진짜 핵심이에요!**

제가 왜 이 단계를 가장 중요하게 생각하냐면, 테스트 코드가 없으면 내가 뭘 고치는지도 모르고, 정말로 고쳐졌는지도 확신할 수 없거든요.

먼저 **실패하는 테스트부터 작성**해야 해요. "이 버그가 정말 존재한다"는 걸 코드로 증명하는 거죠. 예를 들어 Script 컴포넌트 버그 같은 경우엔 이런 식으로 작성했어요:

```javascript
it('should render class attribute correctly with beforeInInteractive strategy', () => {
  render(<Script className="my-class" strategy="beforeInInteractive" />);
  // 현재는 실패 - className이 그대로 나옴
  expect(document.querySelector('[class="my-class"]')).toBeInTheDocument();
});
```

이 테스트를 돌리면 빨간색으로 실패하죠. "좋아, 버그가 진짜 있구나!" 이걸 커밋해두세요.

그 다음에 버그를 고치는 코드를 작성하고, 테스트가 초록색으로 바뀌는 순간이 정말 짜릿해요. "내가 정말로 문제를 해결했구나!"라는 확신이 생기거든요.

**왜 이 과정이 중요하냐면:**

- 메인테이너들이 "이 사람이 정말 문제를 이해했구나"라고 인정해줘요
- 나중에 비슷한 버그가 다시 생기는 걸 방지할 수 있어요
- PR 리뷰할 때 "어떤 문제를 해결했는지" 명확하게 보여줄 수 있어요

**3단계: PR 제출**
프로젝트의 기여 가이드라인을 철저히 따르고, 커밋 메시지 컨벤션도 맞춰주세요. PR 템플릿을 꼼꼼히 작성하고, 변경사항을 명확하게 설명하며, 테스트 결과도 첨부하세요. 그리고 리뷰어 피드백에는 바로바로 대응하는 게 성공의 열쇠예요.

## 슬라이드 18-19: 지금 당장 할 수 있는 것

오늘부터 시작할 수 있는 구체적인 행동 계획을 제시합니다.

**1. 자주 쓰는 라이브러리 선택**
매일 사용하는 라이브러리 하나 선택하기 (react-router, axios, lodash 등), 자신이 자주 사용하는 함수 생각하기, 코드 읽기에 부담 없는 작은 라이브러리부터
시작하는 것이 좋습니다.

**3. 내부 구현 이해하기**
학습 구현 코드 읽기, 주석과 문서 함께 참고하며 "아 이렇게 동작하는구나" 경험하기가 핵심입니다.

**CONTRIBUTING.md 정독과 환경 구축 및 AI 활용**도 즉시 시작할 수 있는 실용적인 방법들입니다.

프로젝트의 기여 가이드라인을 꼼꼼히 읽기, 환경 구축 방법과 PR 규칙 파악하기, clone & 의존성 설치, Claude Code /init으로 AI에게 질문하기 등을 통해 바로
시작할 수 있습니다.

## 슬라이드 20: 질의응답

오픈소스 기여에 관한 여러분의 질문을 받겠습니다.

발표 내용에 대한 추가 질문이나 오픈소스 기여 경험에 대한 궁금한 점이 있으시면 언제든지 들어보세요.

감사합니다!
