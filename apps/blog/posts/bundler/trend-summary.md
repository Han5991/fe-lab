---
title: "2026 번들러 트렌드 요약 (Vite+Rolldown, Turbopack, Rspack)"
date: "2026-01-05"
tags: ["bundler", "trend", "rust"]
---

# 2026 번들러 트렌드 요약: 3강 체제의 이해

이 문서는 "나만의 번들러 만들기" 시리즈를 작성하며 정리한 최신 번들러 트렌드 요약본입니다. 현재 프론트엔드 빌드 도구 시장은 **Rust**를 기반으로 한 성능 혁신을 중심으로 3파전 양상을 보이고 있습니다.

## 1. Vite + Rolldown (The New Standard)
*   **정체성:** "Rollup의 후계자 + Rust의 성능"
*   **목표:** 프론트엔드 툴체인의 **천하통일 (App + Library / Dev + Prod)**
*   **핵심 변화:**
    *   기존 Vite의 이중 구조(Dev: esbuild, Prod: Rollup)를 **Rolldown** 하나로 통합.
    *   앱 개발뿐만 아니라 **라이브러리 번들링**에서도 강력한 성능과 편의성 제공 (기존 `tsup` 등의 수요 흡수).
*   **강점:** 압도적인 생태계(Vue, Svelte, React SPA 등)와 범용성.
*   **의의:** 우리가 공부하는 **ESM First** 철학을 가장 잘 계승하고 있는 모델.

## 2. Turbopack (The Challenger / Future Webpack)
*   **정체성:** "Webpack 창시자(Tobias Koppers)가 만든 Rust 기반의 차세대 번들러"
*   **목표:** **Webpack의 진정한 계승자**이자 Next.js의 전용 엔진.
*   **핵심 특징:**
    *   **Incremental Computation (증분 계산):** 파일 변경 시 영향받는 최소한의 부분만 재계산하는 아키텍처. 이론적으로 프로젝트가 커질수록 Vite보다 빠름.
    *   현재는 **Next.js** 생태계에 최적화되어 있음.
*   **경쟁 구도:** Vite 진영 vs Next.js(Vercel) 진영의 대리전 양상.

## 3. Rspack (The Pragmatist)
*   **정체성:** "Webpack 설정을 그대로 쓰는 Rust 번들러"
*   **목표:** **레거시 Webpack 프로젝트의 구원투수.**
*   **핵심 특징:**
    *   Webpack의 설정과 플러그인 생태계를 거의 그대로 지원하면서 속도만 Rust급으로 향상.
    *   ByteDance 주도로 개발됨.
*   **타겟:** Webpack에서 벗어나고 싶지만, 마이그레이션 비용이 너무 커서 엄두를 못 내는 **대규모 엔터프라이즈** 프로젝트.

## 결론: 왜 지금 번들러를 직접 만들어보는가?
이 모든 최신 도구들(Rolldown, Turbopack, Rspack)의 공통점은 **"JavaScript/TypeScript 코드를 파싱(AST)하고, 의존성 그래프(Graph)를 그려서, 하나로 합친다(Bundle)"**는 본질적인 원리를 공유한다는 점입니다. 단지 그 도구가 JS에서 Rust로 바뀌었을 뿐입니다.

따라서 이 시리즈를 통해 JS로 번들러의 **핵심 원리(Core Principles)**를 이해하는 것은, 단순히 장난감(Toy)을 만드는 것이 아니라 **미래의 도구들이 어떻게 동작하는지 꿰뚫어 보는 통찰력**을 기르는 과정입니다.


---

# [심화] 번들러의 기술적 선택: CJS vs ESM

번들러를 이해하는 데 있어 가장 중요한 기술적 배경 중 하나인 **모듈 시스템의 차이**를 정리합니다. 왜 현대의 모든 번들러(Vite, Rolldown 등)는 CJS를 버리고 ESM을 선택했을까요?

## 1. 직관성 vs 견고함 (Intuition vs Robustness)
- **CJS (CommonJS):** "함수를 실행해서 변수에 담는다"는 **명령형(Imperative)** 방식입니다. 매우 직관적이고 배우기 쉽습니다. 하지만 런타임에 실행해봐야만 결과를 알 수 있다는 불확실성이 존재합니다.
- **ESM (ECMAScript Modules):** "이 모듈은 저 모듈과 연결된다"는 **선언형(Declarative)** 방식입니다. 구조가 엄격하지만, 실행하지 않고도 코드를 분석할 수 있어 안전하고 최적화에 유리합니다.

## 2. Live Binding (라이브 바인딩)의 미학
가장 큰 차이는 값을 다루는 방식입니다.
- **CJS (Snapshot):** 값을 **복사(Copy)**합니다. 모듈 A가 B를 가져온 후, B의 값이 바뀌어도 A가 가진 값은 그대로입니다. (마치 복사해둔 문서처럼)
- **ESM (Reference):** 값을 **연결(Link)**합니다. 메모리 주소를 공유하기 때문에, 모듈 B의 값이 바뀌면 A에서도 즉시 반영됩니다. (마치 CCTV 화면처럼)

## 3. 결정적 이유: 순환 참조 (Circular Dependency)
CJS가 표준이 되지 못한 기술적인 이유는 **순환 참조(A↔B)** 문제입니다.
- CJS는 동기적으로 실행되다가 순환 참조를 만나면, 아직 실행이 덜 끝난 모듈의 **빈 객체(`{}`)**를 반환해버려 런타임 에러를 유발합니다.
- ESM은 **"평가(Parsing)"**와 **"실행(Execution)"** 단계를 분리하여, 값을 채우기 전에 **메모리 방(Reference)**만 미리 잡아두는 방식으로 이 문제를 우아하게 해결합니다.

> **결론:** 현대의 번들러들이 ESM을 선택한 것은 단순한 유행이 아니라, **웹 환경에서의 비동기 로딩, 최적화(Tree Shaking), 그리고 복잡한 의존성 관리**를 위한 필수 불가결한 선택이었습니다.
