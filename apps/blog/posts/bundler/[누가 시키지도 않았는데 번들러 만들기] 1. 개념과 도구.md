---
title: '[누가 시키지도 않았는데 번들러 만들기] 1. 개념과 도구: 번들러가 태어난 이유'
description: '스크립트 태그의 지옥에서 ESM까지, 번들러가 필요해진 역사적 배경과 우리가 사용할 핵심 도구(Magic String)를 알아봅니다.'
date: '2026-02-02'
slug: 'no-one-asked-library-bundler-01-concept'
thumbnail: 'bundler-concept-thumb.png'
published: true
tags: ['bundler', 'javascript', 'history', 'esm', 'magic-string']
excerpt: '왜 우리는 코드를 하나로 합쳐야 할까요? 자바스크립트 모듈 시스템의 역사와 번들러 구현을 위한 강력한 무기, Magic String을 소개합니다.'
---

# 1. 개념과 도구: 번들러가 태어난 이유

> **"그냥 HTML에 `<script>` 태그 여러 개 쓰면 안 되나요?"**

개발을 처음 시작할 때 한 번쯤 해보는 생각입니다. 파일이 늘어나면 태그를 늘리면 되고, 라이브러리가 필요하면 CDN 링크를 복사해 넣으면 그만 아닌가? 왜 굳이 '빌드'라는 복잡한 과정을 거쳐야 할까요?

이 질문에 답하려면 시계를 조금 뒤로 돌려봐야 합니다. 자바스크립트가 아직 '장난감 언어' 취급을 받던 시절로 말이죠.

---

## 🕰️ 모듈 시스템의 흑역사 (그리고 진화)

### 1. 전역 스코프(Global Scope)의 지옥

초기의 자바스크립트는 파일을 나누는 기준이 모호했습니다. `a.js`에서 선언한 변수는 `b.js`에서도 접근할 수 있었죠. 이게 편해 보이지만, 실제로는 재앙이었습니다.

```html
<script src="jquery.js"></script>
<script src="slider.js"></script>
<script src="main.js"></script>
```

만약 `slider.js`와 `main.js`가 우연히 같은 이름의 변수(`var index = 0`)를 쓴다면? 나중에 로드된 파일이 앞의 변수를 덮어버립니다. 이를 막기 위해 개발자들은 변수명에 `_`를 붙이거나 네임스페이스 객체를 만드는 눈물겨운 사투를 벌였습니다.

### 2. IIFE (즉시 실행 함수) - 스스로 감옥 만들기

이 문제를 해결하기 위해 등장한 것이 **IIFE** 패턴입니다.

```javascript
(function () {
  var privateVar = 'I am safe';
  window.MyModule = {
    sayHello: function () {
      console.log(privateVar);
    },
  };
})();
```

함수 스코프를 이용해 변수를 가두고, 필요한 것만 `window`에 노출하는 방식입니다. 우리가 Step 3에서 구현할 번들링 결과물도 바로 이 패턴을 사용합니다. (가장 원시적이지만 가장 확실한 격리 방법이기 때문이죠.)

### 3. CommonJS - 혁명, 하지만 반쪽짜리

2009년, Node.js가 등장하면서 상황이 바뀝니다. **"파일이 곧 모듈이다"** 라는 개념이 확립된 것이죠.

```javascript
// math.js
const add = (a, b) => a + b;
module.exports = add;

// main.js
const add = require('./math');
```

혁명적이었습니다. 하지만 치명적인 단점이 있었으니, **브라우저는 `require`를 모른다**는 것이었습니다. 게다가 `require`는 동기 방식으로 동작해서, 파일을 다 읽을 때까지 브라우저가 멈춰버릴 위험이 있었습니다.

### 4. ESM (ECMAScript Modules) - 드디어 표준이 되다

오랜 혼란 끝에 2015년(ES6), 자바스크립트 공식 모듈 시스템인 **ESM**이 등장합니다. 이제 브라우저도 `<script type="module">`을 통해 모듈을 이해합니다.

---

## 🏗️ 왜 아직도 번들러가 필요한가?

Vite나 Webpack 같은 번들러가 여전히 필수인 이유는 크게 두 가지입니다.

1.  **성능 (Performance)**:
    브라우저가 ESM을 지원한다 해도, 파일이 100개라면 HTTP 요청도 100번 발생합니다. 네트워크 오버헤드는 여전히 큽니다. 파일을 하나(혹은 몇 개)로 합치는 '번들링'은 여전히 가장 강력한 최적화 수단입니다.

2.  **생태계의 파편화 (Compatibility)**:
    npm에 있는 수많은 라이브러리는 여전히 CJS(CommonJS)로 작성되어 있습니다. 브라우저에서 바로 돌릴 수 없는 이 코드들을 해석하고 변환해주는 '통역사'가 필요합니다.

우리가 만들 번들러는 바로 이 **"흩어진 파일들을 찾아서(Resolve), 순서를 정하고(Graph), 하나로 합치는(Bundle)"** 역할을 수행합니다.

---

## ⚔️ 우리의 무기 1: ESM (정적 분석의 힘)

우리는 번들러를 만들 때 **ESM 문법을 기반**으로 할 것입니다. 왜냐고요?

### 정적 분석 (Static Analysis) vs 동적 실행

CommonJS(`require`)는 함수이기 때문에 `if`문 안에서 조건부로 실행될 수 있습니다. 코드를 돌려보지 않으면 무엇을 import 하는지 알 수 없죠.

반면 **ESM(`import`)은 정적**입니다. 파일의 최상단에만 위치해야 하므로, 코드를 실행하지 않고 텍스트만 읽어서도 **"누가 누구를 의존하는지" 100% 확신**할 수 있습니다. 이것이 바로 우리가 만들 번들러가 복잡한 실행기 없이도 의존성 그래프를 그릴 수 있는 비결이며, **트리 쉐이킹(Tree Shaking)** 의 기술적 토대입니다.

### Live Binding (실시간 연결)

ESM은 값을 복사하지 않고 **참조**합니다.

- **CJS**: 값을 가져오는 시점의 '스냅샷'입니다.
- **ESM**: 원본 변수를 가리키는 '통로'입니다. 원본이 바뀌면 가져온 값도 바뀝니다.

**이게 왜 중요할까요? 바로 순환 참조 때문입니다.**
`A -> B -> A` 처럼 서로를 참조하는 상황을 상상해봅시다.
CJS에서는 A가 실행 중에 B를 부르고, B가 다시 A를 부르면 문제가 생깁니다. A는 아직 실행이 끝나지 않아 `exports` 객체가 비어있는데, B는 그 시점의 빈 객체를 **복사**해가기 때문입니다. 결국 `undefined` 에러가 터집니다.

반면 ESM은 "값이 들어올 자리"를 미리 연결 해둡니다. 비록 지금은 값이 없더라도, 나중에 A가 실행을 마치고 값을 채워 넣으면 B도 그 즉시 올바른 값을 볼 수 있게 됩니다. 이러한 특성 덕분에 번들러는 복잡하게 얽힌 의존성 관계도 안전하게 풀어낼 수 있습니다.

---

## 🪄 우리의 무기 2: Magic String

번들러를 구현한다는 건 결국 **"코드를 읽어서 문자열을 조작하는 일"** 입니다.
`import`를 지우고, 변수명을 바꾸고, 코드를 합쳐야 하죠.

보통 문자열을 바꿀 때 `String.prototype.replace`를 생각하기 쉽습니다. 하지만 코드 조작에서는 이게 지옥의 문을 엽니다.

### ❌ 단순 replace의 문제점

문자열을 한번 수정하면 전체 길이가 바뀝니다. 즉, **인덱스가 밀립니다.**
앞부분의 `import` 구문을 지우면, 뒷부분 코드의 위치(Start/End)가 전부 바뀌어버려 추가적인 조작이 불가능해집니다.

### ✅ Magic String의 마법 (실제 구현 예시)

`magic-string` 라이브러리는 이 문제를 우아하게 해결합니다. 변경 사항을 큐(Queue)에 쌓아뒀다가 한 번에 처리하므로, 항상 **원본 코드의 인덱스**를 기준으로 작업할 수 있습니다.

실제 우리가 구현할 번들러(`Module.ts`)의 핵심 로직을 미리 볼까요? `import` 문을 `require`로 바꾸는 코드입니다.

```typescript
// packages/@package/bundler/src/Module.ts (실제 구현 코드)

private transformImportDeclaration(node) {
  // 1. import된 모듈의 ID를 가져옵니다.
  const depId = this.mapping.get(node.source.value);
  const requireCall = `require('${depId}')`;

  // 2. 바꿀 문자열을 만듭니다.
  // 예: import { a } from './file' => const { a } = require('file')
  const replacement = `const { ${specifierStr} } = ${requireCall};\n`;

  // 3. ✨ Magic String으로 덮어씁니다.
  // node.start와 node.end는 원본 소스의 위치입니다.
  // 다른 곳을 아무리 수정해도 이 좌표는 변하지 않습니다!
  this.magicString.overwrite(node.start, node.end, replacement);
}
```

가장 중요한 건 **소스맵** 입니다. 우리가 코드를 제아무리 뒤죽박죽 섞어도, `magicString.generateMap()` 한 방이면 원본 코드의 위치를 가리키는 소스맵을 만들어줍니다. 이게 없으면 나중에 디버깅할 때 번들링된 코드만 보고 울게 될지도 모릅니다.

---

## 🧭 실습 준비: 예제 코드 위치와 흐름

이 시리즈를 따라오기 위해 봐야 할 **실습용 예제 코드**의 위치를 알려드립니다. 각 Step에서 "도대체 어느 파일을 봐야 하지?" 싶을 때 이 지도를 참고하세요.

```text
packages/@package/bundler/
├── src/index.ts   # 파이프라인 진입점 (entry 설정 -> build -> generate)
├── src/Graph.ts   # 의존성 그래프 구축, 순환 참조 해결, 번들 생성
└── src/Module.ts  # 개별 파일의 AST 파싱 및 ESM -> CJS 변환
```

### 실습 흐름 (Step별 참조 파일)

- **Step 1 (현재)**: `src/index.ts`의 전체 파이프라인 감 잡기
- **Step 2**: `src/Module.ts` (파일 분석) + `src/Graph.ts` (관계 연결)
- **Step 3**: `Graph.generate()` (번들링) + `Module.transform()` (코드 변환)
- **Step 4**: `dist/index.js.map` (소스맵 확인)

---

## 🎬 실전: 10줄로 만드는 초미니 번들러 (MVP)

개념만 공부하고 넘어가기엔 손이 근질거리지 않나요?
파일 하나를 읽어서 그대로 내보내는, 세상에서 가장 단순한 번들러를 만들어보며 1단계를 마무리합시다.

```javascript
import fs from 'node:fs';
import MagicString from 'magic-string';

// 1. 파일 읽기 (모듈 해석 단계의 기초)
const content = fs.readFileSync('./src/index.js', 'utf-8');

// 2. MagicString으로 감싸기 (변환의 기초)
const bundle = new MagicString(content);

// 3. (가정) 여기서 코드를 분석하고 변환하는 작업이 들어갑니다.
bundle.prepend('/* Bundled by My Own Bundler */\n');

// 4. 결과물 쓰기 (생성 단계)
fs.writeFileSync('./dist/bundle.js', bundle.toString());
console.log('Build completed! 🚀');
```

이 10줄 남짓한 코드가 바로 우리가 만들 거대한 번들러의 **아주 작은 씨앗(MVP)** 입니다. 지금은 단순히 파일을 복사하는 수준이지만, 앞으로 우리는 저 3번 주석 자리에 **AST 분석, 의존성 그래프 탐색, 코드 변환 로직**을 하나씩 채워 넣을 것입니다.

---

## 🚀 다음 단계 예고

이제 기초 체력은 충분히 길렀습니다. 다음 단계에서는 실제로 코드를 데이터로 변환하여 분석하는 **AST 분석과 의존성 그래프 구현**의 세계로 들어가 보겠습니다.

**[Step 2. 그래프 그리기 (Resolve & AST) 로 이동]** `Coming Soon`
