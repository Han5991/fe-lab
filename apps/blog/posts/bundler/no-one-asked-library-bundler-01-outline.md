---
title: '누가 시키지도 않았는데 라이브러리 번들러 만들기'
description: '번들러 내부 흐름을 직접 구현하며 라이브러리 번들링의 판단 과정을 기록하는 시리즈 목차.'
date: '2025-12-22'
slug: 'no-one-asked-library-bundler-01-outline'
tags: ['bundler', 'library', 'build', 'tooling']
excerpt: '번들러가 어떤 판단을 거쳐 결과물을 만드는지 직접 구현하며 따라가는 시리즈 목차.'
---

> 누가 시키지도 않았지만, 직접 만들어 보면 번들러가 어떻게 숨 쉬는지 보인다.

## 시리즈 목표

이 시리즈는 ‘실무에서 쓰기 위한 번들러’를 만드는 글이 아니다.  
번들러가 어떤 판단을 거쳐 결과물을 만들어내는지,
그 내부 흐름을 이해하기 위한 기록이다.

- 라이브러리 번들러의 핵심 흐름을 직접 구현한다.
- 도구가 대신 해주던 선택을 하나씩 손으로 내려본다.
- 최소 기능(ESM/CJS, 타입, sourcemap)까지 도달한다.
- 핵심 단계마다 다이어그램으로 흐름을 시각화한다.

## 목차

1. 프롤로그: 시리즈 목표와 독자 범위
2. 기본 개념: 프론트엔드 번들링이란 무엇인가 (다음 글에서 상세히)
   - 번들링 정의: 여러 모듈을 빌드 타임에 묶는 과정
   - 라이브러리 번들링 vs 앱 번들링: 배포/호환성 중심 vs 런타임 최적화 중심
   - 모듈/패키지/엔트리: 그래프의 시작점과 범위
   - 의존성 그래프: 모듈 관계를 그래프로 구성하는 이유
   - 모듈 해석(resolve): 경로와 패키지 이름을 실제 파일로 찾는 규칙
   - 변환 파이프라인: parse → transform → generate 흐름
   - 출력 포맷 개요: ESM/CJS/UMD와 tree shaking의 전제
   - externals/peer deps: 번들러가 건드리지 않는 것들
   - 산출물 종류: 번들 파일 외에 sourcemap, d.ts
   - 범위 선언: 코드 스플리팅/자산 처리 등은 제외
3. 모듈 시스템 상세: ESM/CJS/UMD와 라이브러리 번들링의 이유
4. 범위/스펙·설계: 목표·비목표, 모듈/패키지/엔트리, entry/exports, 산출물 종류
5. MVP: 단일 파일 번들러로 파이프라인 맛보기 (parse → transform → generate)
6. 모듈 해석: Node.js resolve 알고리즘 흉내 내기
7. 의존성 그래프: AST로 파헤치는 모듈 관계도 (순환 참조, 캐시)
8. 변환 파이프라인: Babel/SWC 없이 해보는 최소 트랜스파일링
9. 출력 포맷: CJS/ESM 듀얼 패키지와 tree shaking 관점
10. external 처리: 번들러가 “건드리지 않는 것들”
11. 타입/소스맵: d.ts와 sourcemap 출력
12. 검증과 비교: 실제 라이브러리 묶기 + Rollup/esbuild 차이

## 연습용 레포 구성 (미리보기)

번들러와 실제 소비 대상을 분리해,
도구와 결과물을 동시에 검증한다.

- packages/@package/bundler
- packages/@package/sample-lib
