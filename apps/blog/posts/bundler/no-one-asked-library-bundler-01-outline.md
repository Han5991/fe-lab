---
title: '누가 시키지도 않았는데 라이브러리 번들러 만들기'
description: '번들러 내부 흐름을 직접 구현하며 라이브러리 번들링의 판단 과정을 기록하는 시리즈 목차.'
date: '2025-12-22'
slug: 'no-one-asked-library-bundler-01-outline'
tags: ['bundler', 'library', 'build', 'tooling']
excerpt: '번들러가 어떤 판단을 거쳐 결과물을 만드는지 직접 구현하며 따라가는 시리즈 목차.'
---

> 누가 시키지도 않았지만, 직접 만들어 보면 번들러가 어떻게 숨 쉬는지 보인다.

## 시리즈 목표

> 이 시리즈는 ‘실무에서 쓰기 위한 번들러’를 만드는 글이 아니다.  
> 번들러가 어떤 판단을 거쳐 결과물을 만들어내는지,  
> 그 내부 흐름을 이해하기 위한 기록이다.

- 라이브러리 번들러의 핵심 흐름을 직접 구현한다.
- 도구가 대신 해주던 선택을 하나씩 손으로 내려본다.
- 최소 기능(ESM/CJS, 타입, sourcemap)까지 도달한다.
- 핵심 단계마다 다이어그램으로 흐름을 시각화한다.

## 목차

1. 프롤로그: 시리즈 목표와 독자 범위
2. 기본 개념: 라이브러리 번들러의 해부도
   - 번들링의 목적: 왜 빌드 타임에 모듈을 묶어야 하는가?
   - 라이브러리 vs 앱 번들러: 배포/호환성 중심 vs 런타임 최적화 중심
     - 왜 라이브러리 번들러는 리액트를 포함하지 않는가? (Externals)
     - 누가 내 라이브러리를 쓰는가? (CJS/ESM, d.ts)
   - 번들러의 3단계 라이프사이클:
     - [입력] Entry, Resolve, Dependency Graph (어디서 시작해서 무엇을 찾을 것인가)
     - [가공] Parse, Transform (어떻게 코드를 읽고 입맛에 맞게 고칠 것인가)
     - [출력] Generate, Format (어떤 형태로 내보내고 무엇을 제외할 것인가)
   - 범위 선언: 코드 스플리팅, 자산 처리, HMR 등 '앱 전용 기능' 제외하기
3. 모듈 시스템 상세: ESM/CJS/UMD와 라이브러리 번들링의 이유
4. 범위/스펙·설계: 목표·비목표, 모듈/패키지/엔트리, entry/exports, 산출물 종류
5. MVP: 단일 파일 번들러로 파이프라인 맛보기 (parse → transform → generate)
6. 모듈 해석: Node.js resolve 알고리즘 흉내 내기
7. 의존성 그래프: AST(acorn)로 파헤치는 모듈 관계도 (순환 참조, 캐시)
8. 변환 파이프라인: magic-string을 활용한 코드 변환과 래핑
9. 출력 포맷: CJS/ESM 듀얼 패키지와 Tree Shaking (미사용 모듈 제외 수준)
10. external 처리: 번들러가 “건드리지 않는 것들”
11. 타입/소스맵: Sourcemap의 원리와 단순화된 구현 (Line-to-Line)
12. 검증과 비교: 실제 라이브러리 묶기 + Rollup/esbuild 차이

## 연습용 레포 구성 (미리보기)

번들러와 실제 소비 대상을 분리해,
도구와 결과물을 동시에 검증한다.

- packages/@package/bundler
- packages/@package/sample-lib
