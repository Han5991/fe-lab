---
title: '누가 시키지도 않았는데 라이브러리 번들러 만들기'
description: '번들러 내부 흐름을 직접 구현하며 라이브러리 번들링의 판단 과정을 기록하는 시리즈 목차.'
date: '2025-12-22'
slug: 'no-one-asked-library-bundler-01-outline'
tags: ['bundler', 'library', 'build', 'tooling']
excerpt: '번들러가 어떤 판단을 거쳐 결과물을 만드는지 직접 구현하며 따라가는 시리즈 목차.'
---

> 누가 시키지도 않았지만, 직접 만들어 보면 번들러가 어떻게 숨 쉬는지 보인다.

## 시리즈 목표

이 시리즈는 ‘실무에서 쓰기 위한 번들러’를 만드는 글이 아니다.  
번들러가 어떤 판단을 거쳐 결과물을 만들어내는지,
그 내부 흐름을 이해하기 위한 기록이다.

- 라이브러리 번들러의 핵심 흐름을 직접 구현한다.
- 도구가 대신 해주던 선택을 하나씩 손으로 내려본다.
- 최소 기능(ESM/CJS, 타입, sourcemap)까지 도달한다.
- 핵심 단계마다 다이어그램으로 흐름을 시각화한다.

## 목차

1. 프롤로그: 왜 굳이 라이브러리 번들러인가
2. 범위 정의: 무엇을 만들고, 무엇을 포기할 것인가
3. 입출력 스펙: entry, package.json 필드, 결과물 구조
4. 프로젝트 설계: 모노레포에서 패키지로 나누는 이유
5. 모듈 해석: Node.js resolve 알고리즘 흉내 내기
6. 의존성 그래프: AST로 파헤치는 모듈 관계도 (순환 참조 포함)
7. 변환 파이프라인: Babel/SWC 없이 해보는 최소 트랜스파일링
8. 번들 생성: CJS/ESM, 그리고 ESM이 tree shaking에 유리한 이유
9. external 처리: 번들러가 “건드리지 않는 것들”
10. 타입/소스맵: d.ts와 sourcemap 출력
11. 검증: 실제 라이브러리를 묶어보며 생긴 문제들
12. 에필로그: Rollup, esbuild는 무엇이 달랐나

## 연습용 레포 구성 (미리보기)

번들러와 실제 소비 대상을 분리해,
도구와 결과물을 동시에 검증한다.

- packages/@package/bundler
- packages/@package/sample-lib
