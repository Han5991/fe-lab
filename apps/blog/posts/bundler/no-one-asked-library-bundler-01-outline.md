---
title: '누가 시키지도 않았는데 라이브러리 번들러 만들기'
description: '번들러 내부 흐름을 직접 구현하며 라이브러리 번들링의 판단 과정을 기록하는 시리즈 목차.'
date: '2025-12-22'
slug: 'no-one-asked-library-bundler-01-outline'
tags: ['bundler', 'library', 'build', 'tooling']
excerpt: '번들러가 어떤 판단을 거쳐 결과물을 만드는지 직접 구현하며 따라가는 시리즈 목차.'
---

> 누가 시키지도 않았지만, 직접 만들어 보면 번들러가 어떻게 숨 쉬는지 보인다.

## 시리즈 목표

> 이 시리즈는 ‘실무에서 쓰기 위한 번들러’를 만드는 글이 아니다.  
> 번들러가 어떤 판단을 거쳐 결과물을 만들어내는지,  
> 그 내부 흐름을 이해하기 위한 기록이다.

- 라이브러리 번들러의 핵심 흐름을 직접 구현한다.
- 도구가 대신 해주던 선택을 하나씩 손으로 내려본다.
- 최소 기능(ESM/CJS, 타입, sourcemap)까지 도달한다.
- 핵심 단계마다 다이어그램으로 흐름을 시각화한다.

## 목차

1. 프롤로그: 질문의 시작
2. 기본 개념: 라이브러리 번들러의 해부도
   - **이 챕터는 시리즈의 '전체 지도'입니다.**
   - 번들링의 목적: 왜 빌드 타임에 모듈을 묶어야 하는가?
   - 라이브러리 vs 앱: "리액트를 포함하지 않는다"는 것의 의미 (Externals/PeerDeps)
   - 파이프라인 개요: [입력] → [분석] → [변환] → [생성]의 흐름 잡기
   - *이후 챕터들은 이 지도의 각 구역을 하나씩 상세 구현합니다.*
3. Step 1 (MVP): 파이프라인 뼈대 만들기
   - **연관 개념:** 파이프라인 개요, 모듈 시스템(ESM/CJS)
   - 목표: 복잡한 로직 없이, 파일 하나를 읽어 변환 후 다시 쓰는 '최소 기능' 구현
   - 핵심: `magic-string`을 이용한 문자열 조작 맛보기
4. Step 2 (분석): 모듈 탐색과 의존성 그래프
   - **연관 개념:** [입력] Resolve, Dependency Graph
   - 목표: `import` 문을 추적하여 모든 파일을 찾고(Resolve), 그 관계를 연결하기
   - 핵심: Node.js의 모듈 찾기 규칙 구현과 순환 참조 해결
5. Step 3 (생성): 번들링과 External 전략
   - **연관 개념:** [변환] Transform, [생성] Generate, Externals
   - 목표: 흩어진 모듈을 올바른 순서로 합치고, 외부 라이브러리(`react` 등)를 격리하기
   - 핵심: Scope 오염 방지(Naming)와 CJS/ESM 듀얼 모드 출력
6. Step 4 (고도화): 개발자 경험 챙기기
   - **연관 개념:** Sourcemap, d.ts
   - 목표: 디버깅을 위한 소스맵 생성과 타입 정의 파일 처리
   - 핵심: 원본 소스와 번들 코드의 위치 매핑 원리 이해
7. 에필로그: 검증과 회고
   - 우리가 만든 도구로 실제 라이브러리 배포해보기
   - 상용 번들러(Rollup/esbuild)와의 차이점 및 한계 분석

## 연습용 레포 구성 (미리보기)

번들러와 실제 소비 대상을 분리해,
도구와 결과물을 동시에 검증한다.

- packages/@package/bundler
- packages/@package/sample-lib
