---
title: "Step 1: 번들러의 시작, 개념 잡기"
date: null
tags: ["bundler", "javascript", "study"]
---

# Step 1: 번들러의 시작, 개념 잡기

번들러를 직접 만들기 전에, 우리가 만들고자 하는 것이 도대체 무엇인지, 그리고 왜 필요한지에 대한 역사를 짚고 넘어갑시다. 단순히 코드를 합치는 것을 넘어, 웹 개발의 역사가 어떻게 번들러를 필요로 하게 되었는지 이해하면 구현의 방향성이 명확해집니다.

## 1. 번들러(Bundler)란 무엇인가?

번들러는 말 그대로 여러 개의 파일을 하나(혹은 여러 개)의 파일로 **"묶어주는(Bundle)"** 도구입니다. 

웹 애플리케이션의 규모가 커지면서 수많은 자바스크립트 파일을 효율적으로 관리하고 배포해야 하는 문제가 발생했습니다. 수백 개의 자바스크립트 파일을 각각 `<script>` 태그로 로딩한다면 네트워크 요청이 폭증하고, 로딩 순서 관리도 지옥이 될 것입니다. 번들러는 이 파일들을 의존성에 따라 올바른 순서로 하나로 합쳐, 브라우저가 쉽고 빠르게 코드를 실행할 수 있게 돕습니다.

## 2. 자바스크립트 모듈의 역사

우리가 지금 당연하게 사용하는 `import/export`가 표준이 되기까지 자바스크립트 생태계에는 많은 시도들이 있었습니다.

### 1) 태초의 시대: Global Scope & Script Tag
초기에는 단순히 HTML에 `<script>` 태그를 나열했습니다. 파일을 나누어도 모든 변수가 전역 스코프(`window`)를 공유했기 때문에, 서로 다른 파일에서 같은 변수명을 쓰면 충돌이 발생했습니다.

### 2) 스코프의 탄생: IIFE (즉시 실행 함수)
전역 오염을 막기 위해 함수 스코프를 이용하는 패턴이 등장했습니다. 
```js
(function() {
    var privateVar = "secret";
    window.myLibrary = { ... };
})();
```
외부에서 접근할 수 없는 "공간"을 만들었지만, 여전히 파일 간의 의존성 관리(누가 먼저 로딩되어야 하는가?)는 개발자의 몫이었습니다.

### 3) 과도기: CommonJS (CJS) & AMD
- **CommonJS (CJS):** Node.js의 등장과 함께 서버 사이드에서 모듈 시스템이 정립되었습니다. `require`, `module.exports`를 사용하며, 파일 단위로 스코프가 격리됩니다. 하지만 동기적(Synchronous)으로 동작하여 브라우저 환경에는 적합하지 않았습니다.
- **AMD:** 브라우저의 비동기 로딩 환경을 위해 설계되었으나, 문법이 복잡하고 가독성이 좋지 않았습니다.

### 4) 표준의 등장: ESM (ECMAScript Modules)
ES6(ES2015)에서 드디어 언어 차원의 표준 모듈 시스템이 등장했습니다. `import`, `export` 문법을 사용하며, 브라우저와 Node.js 모두에서 지원(Node.js는 점진적 지원)하게 되었습니다.

## 3. 모던 번들러의 역할

오늘날의 번들러(Webpack, Vite, Rollup, Parcel 등)는 단순히 파일을 합치는 것을 넘어 프론트엔드 빌드 파이프라인의 핵심 역할을 수행합니다.

- **모듈 통합:** ESM, CJS 등 다양한 모듈 시스템이 섞여 있어도 문제없이 동작하도록 호환성을 챙겨줍니다.
- **트랜스파일링(Transpilation):** Babel, SWC 등을 연동하여 TypeScript나 최신 문법을 구형 브라우저에서도 돌아가도록 변환합니다.
- **최적화(Optimization):** 
    - **Minification:** 공백 제거, 변수명 단축으로 파일 크기 감소
    - **Tree Shaking:** 사용하지 않는 코드 제거
    - **Code Splitting:** 초기 로딩 속도를 위해 파일을 여러 개로 분리
- **개발 경험(DX):** 개발 서버(Dev Server)와 HMR(Hot Module Replacement)을 제공하여 코드 수정 사항을 즉시 브라우저에 반영합니다.

## 4. 번들러의 진화: Vite와 Rolldown

최근 프론트엔드 생태계는 **Vite**가 사실상의 표준으로 자리 잡았습니다. 하지만 Vite에게도 아직 해결해야 할 과제가 있습니다. 바로 **앱(App)과 라이브러리(Library) 번들링의 간극**입니다.

### 1) 현재 Vite의 딜레마: "두 개의 심장"
Vite는 현재 두 가지 번들러를 섞어서 사용합니다.
- **개발 모드:** **esbuild**를 사용하여 압도적인 속도를 자랑합니다.
- **프로덕션 빌드:** **Rollup**을 사용하여 안정적이고 유연한 번들링을 수행합니다.

이로 인해 "개발 환경에서는 잘 되는데 빌드하면 안 되는" 미세한 불일치 문제가 발생할 수 있습니다. 또한, Vite는 본래 **웹 애플리케이션**을 만들기 위해 태어났기 때문에, 복잡한 설정이 필요한 **라이브러리 번들링**에 있어서는 Rollup을 직접 쓰는 것보다 다소 제약이 있거나 무거운 경우가 있었습니다.

### 2) Rolldown: Rust로 다시 쓴 Rollup
이 문제를 해결하기 위해 등장한 것이 **Rolldown**입니다. Rolldown은 Rollup의 API와 플러그인 생태계를 100% 호환하면서, 내부는 **Rust**로 다시 작성하여 esbuild급의 속도를 내는 것을 목표로 합니다.

- **Vite의 미래:** 앞으로 Vite는 내부 번들러를 Rolldown으로 통합할 예정입니다.
- **완벽한 라이브러리 번들러:** Rolldown이 통합되면 Vite는 앱뿐만 아니라 라이브러리 번들링에서도 압도적인 성능과 호환성을 제공하게 될 것입니다. 우리가 지금 ESM과 번들러 구조를 배우는 것은, 바로 이 차세대 도구들이 동작하는 원리를 가장 밑바닥에서 이해하는 과정이기도 합니다.

### 3) 그렇다면 Vite+는 만능이 될까요? (Vite vs Turbopack)

Rolldown을 탑재한 Vite는 분명 **프론트엔드 툴체인의 천하통일**에 가장 가까운 도구입니다. "앱은 Vite, 라이브러리는 tsup" 처럼 나누던 경계가 사라지고, 개발과 배포 환경이 하나로 통합되기 때문입니다.

하지만 **"유일한 적수"**가 있습니다. 바로 Next.js 진영의 **Turbopack**입니다.
현재 리액트 생태계의 거물인 Vercel은 Vite 대신 자체적으로 만든 Rust 기반 번들러인 Turbopack을 Next.js의 엔진으로 밀고 있습니다.

앞으로의 프론트엔드 빌드 도구 시장은 **"범용적인 표준을 지향하는 Vite(Rolldown)"**와 **"Next.js 생태계에 최적화된 Turbopack"**의 양강 구도로 흘러갈 가능성이 높습니다. 우리가 만드는 번들러는 이 거대한 흐름 속에서 "Vite/Rolldown"이 추구하는 **ESM 기반의 범용적인 철학**을 공유하고 있습니다.

### 4) 보너스: Rspack과 번들러 삼국지

여기에 더해 **Rspack**이라는 강력한 도전자도 있습니다.
- **Rspack (Rust + Webpack):** "Webpack 설정을 그대로 쓰면서 속도만 Rust급으로 올리고 싶다"는 기업들의 니즈를 타격했습니다. 
- ByteDance가 주도하는 Rspack은 Webpack의 방대한 생태계를 버릴 수 없는 대규모 기업들에게 **현실적인 구원투수** 역할을 하고 있습니다.

결국 2026년 현재 프론트엔드 번들러 시장은 **"3파전(Vite+Rolldown vs Turbopack vs Rspack)"** 양상을 보이고 있습니다.
하지만 이들의 공통점은 모두 **Rust**를 사용하여 **근본적인 성능 혁신**을 꾀하고 있다는 점입니다.



---

## 5. 구현의 핵심 1: 모듈 시스템의 선택 (ESM)

우리가 만들 번들러는 **ESM(ECMAScript Modules)** 을 기반으로 동작합니다. 왜 CJS가 아니라 ESM일까요? 단순히 최신 기술이라서가 아니라, **번들러 구현의 난이도와 성능**에 결정적인 영향을 미치기 때문입니다.

### 정적 분석(Static Analysis) vs 동적 실행(Dynamic Execution)

- **CJS (`require`):**
    `require`는 함수입니다. 즉, 코드의 어느 곳에서든 호출될 수 있습니다.
    ```js
    if (Math.random() > 0.5) {
        const module = require("./a.js"); // 실행해봐야 아는 의존성
    }
    ```
    이 경우, 번들러가 파일을 묶으려면 코드를 실제로 실행해보거나(매우 어려움), 모든 가능성을 포함해야 합니다. 이는 **Tree Shaking(사용하지 않는 코드 제거)** 을 어렵게 만듭니다.

- **ESM (`import`):**
    `import`는 최상위 레벨(Top-level)에서만 선언할 수 있는 정적인 구문입니다.
    ```js
    import { a } from "./a.js"; // 코드를 실행하지 않아도 파악 가능한 의존성
    ```
    번들러는 단순히 파일의 텍스트만 읽어서(Parsing) "아, 이 파일은 a.js가 필요하구나"라고 100% 확신할 수 있습니다. 이것이 우리가 **Dependency Graph(의존성 그래프)** 를 쉽게 그릴 수 있는 이유입니다.

### Live Binding (라이브 바인딩)

ESM의 또 다른 중요한 특징은 바인딩이 살아있다는 점입니다.
CJS는 값을 `복사`해서 내보내지만, ESM은 값을 `참조`로 연결합니다.

```js
// counter.js (ESM)
export let count = 0;
export const inc = () => count++;
```

만약 CJS라면 `require` 시점의 `count` 값(0)이 복사되겠지만, ESM에서는 `inc()`가 호출되어 `count`가 변하면, 이를 import한 쪽에서도 변경된 값을 즉시 볼 수 있습니다. 우리의 번들러는 이 스펙을 준수하기 위해 변수 연결 처리에 신경 써야 합니다.

## 6. 구현의 핵심 2: 문자열 조작과 SourceMap (Magic String)

번들러의 본질은 **"A 파일의 코드를 읽어서 조작한 뒤 B 파일에 쓰는 것"** 입니다. 여기서 "조작"이란 `import` 문을 지우거나, 변수 이름을 바꾸거나, 코드를 다른 파일의 내용으로 교체하는 것을 말합니다.

### 왜 `string.replace`로는 안 될까요?

단순 문자열 치환(`replace`, `slice`)을 사용하면 심각한 문제가 발생합니다.

1.  **인덱스 밀림 현상:** 앞쪽 코드를 수정하여 길이가 바뀌면, 뒤쪽 코드의 모든 위치(Index) 정보가 틀어집니다. 여러 번의 수정을 순서대로 처리하기가 매우 복잡해집니다.
2.  **SourceMap 소실:** 개발자가 보는 코드는 번들링된(합쳐진) 코드입니다. 여기서 에러가 났을 때, 브라우저가 "원본 파일의 10번째 줄에서 에러가 났다"고 알려주려면, **변환된 코드가 원본의 어디에서 왔는지**에 대한 지도(Map)가 필요합니다. 단순 문자열 연산은 이 정보를 모두 날려버립니다.

### Magic String의 역할

그래서 우리는 `magic-string`과 같은 라이브러리를 사용합니다. 이 도구는 문자열을 객체처럼 다루게 해줍니다.

- **변경 사항 추적:** "0번째부터 10번째 문자를 지워라", "20번째 위치에 이 코드를 추가하라" 같은 명령을 쌓아두었다가 한 번에 적용합니다. 인덱스 계산을 라이브러리가 대신 해줍니다.
- **SourceMap 자동 생성:** 변경 사항을 기록해두었기 때문에, 결과물 코드의 어느 부분이 원본의 어디인지 정확히 가리키는 SourceMap을 자동으로 만들어줍니다.

```js
import MagicString from "magic-string";

const s = new MagicString("export var name = \"beepy\";");

// "export var " (길이 11)를 지우고 싶다.
s.remove(0, 11); 

// "name" 뒤에 " = " (길이 3) 건너뛰고 값을 바꾼다.
s.overwrite(14, 21, \"bun\");

console.log(s.toString()); // name = "bun";
// 짜잔! SourceMap도 공짜로 얻습니다.
console.log(s.generateMap().toString()); 
```

우리는 이 도구를 사용해, 원본 소스 코드를 훼손하지 않으면서 브라우저가 이해할 수 있는 하나의 번들 파일로 재조립할 것입니다.
