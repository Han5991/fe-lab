---
title: 'Step 1. 번들러의 시작: 개념 파악과 기술적 토대 다지기'
description: '본격적인 구현에 앞서 번들러의 역사와 핵심 원리인 ESM의 특징, 그리고 코드 조작을 위한 도구를 살펴봅니다.'
date: '2026-01-11'
slug: 'no-one-asked-library-bundler-01-concept'
published: true
tags: ['bundler', 'javascript', 'esm', 'frontend']
excerpt: '웹 개발의 역사가 어떻게 번들러를 필요로 하게 되었을까요? 우리가 만들 번들러의 근간이 되는 ESM과 Magic String의 정체를 알아봅니다.'
---

# Step 1. 번들러의 시작: 개념 파악과 기술적 토대 다지기

본격적으로 번들러를 구현하기 전에, 우리가 만들고자 하는 도구의 정체와 필요성을 명확히 짚고 넘어갈 필요가 있습니다. 단순히 코드를 합치는 행위를 넘어, 웹 개발의 역사가 왜 번들러라는 도구를 선택하게 되었는지 이해하면 구현의 방향성이 훨씬 선명해집니다.

---

## 1. 번들러(Bundler)란 무엇인가?

번들러는 말 그대로 흩어져 있는 여러 개의 파일을 하나(혹은 최적화된 소수)의 파일로 **"묶어주는(Bundle)"** 도구입니다.

웹 애플리케이션의 규모가 커지면서 관리해야 할 자바스크립트 파일은 기하급수적으로 늘어났습니다. 만약 수백 개의 파일을 각각 `<script>` 태그로 로드한다면 어떤 일이 벌어질까요? 네트워크 요청이 폭증하여 성능이 저하되는 것은 물론, 파일 간의 복잡한 로딩 순서를 맞추는 일은 개발자에게 재앙에 가까운 작업이 될 것입니다. 번들러는 이러한 파일들을 **의존성(Dependency)**에 따라 분석하여 올바른 순서로 결합함으로써, 브라우저가 코드를 효율적으로 실행할 수 있도록 돕는 핵심적인 역할을 수행합니다.

## 2. 자바스크립트 모듈의 진화사

우리가 현재 당연하게 사용하는 `import`와 `export`가 표준이 되기까지, 자바스크립트 생태계는 수많은 시행착오를 거쳐왔습니다.

### 1) 태초의 시대: 전역 스코프의 한계

초기에는 모든 자바스크립트 파일이 전역 스코프(`window`)를 공유했습니다. 파일을 나누어도 변수명이 겹치면 충돌이 발생했고, 어떤 파일이 먼저 실행되어야 하는지 수동으로 관리해야만 했습니다.

### 2) 격리의 시작: IIFE (즉시 실행 함수)

전역 오염을 막기 위해 함수 스코프를 활용하는 IIFE 패턴이 등장했습니다.

```javascript
(function () {
  var privateVar = 'secret';
  window.myLibrary = {
    /* ... */
  };
})();
```

이를 통해 외부에서 접근할 수 없는 독립된 공간을 만들었지만, 여전히 파일 간의 의존성 문제는 해결되지 않은 숙제로 남았습니다.

### 3) 과도기: CommonJS(CJS)와 AMD

- **CommonJS (CJS)**: Node.js의 등장과 함께 서버 사이드에서 정착된 시스템입니다. `require`와 `module.exports`를 사용하며 파일 단위의 스코프 격리를 이뤄냈지만, 동기적(Synchronous)으로 동작하는 특성상 브라우저 환경에는 적합하지 않았습니다.
- **AMD (Asynchronous Module Definition)**: 브라우저의 비동기 로딩을 위해 설계되었으나, 문법이 난해하고 가독성이 떨어져 널리 퍼지지 못했습니다.

### 4) 표준의 정립: ESM (ECMAScript Modules)

ES6(2015)에서 드디어 언어 차원의 표준 모듈 시스템이 등장했습니다. 바로 우리가 익숙한 `import`와 `export`입니다. ESM은 브라우저와 Node.js 환경 모두를 아우르는 현대적 자바스크립트 개발의 근간이 되었습니다.

---

## 3. 현대 번들러의 역할과 생태계의 변화

오늘날의 번들러(Webpack, Vite, Rollup 등)는 단순히 파일을 합치는 기능을 넘어 **프론트엔드 빌드 파이프라인의 사령탑** 역할을 합니다.

- **모듈 통합**: 서로 다른 모듈 시스템(ESM, CJS 등) 간의 호환성을 보장합니다.
- **트랜스파일링**: 최신 문법이나 TypeScript를 구형 브라우저에서도 동작하는 코드로 변환합니다.
- **최적화**: 미사용 코드를 제거하는 **Tree Shaking**, 파일 크기를 줄이는 **Minification**, 효율적 로딩을 위한 **Code Splitting** 등을 수행합니다.

최근에는 **Vite**를 중심으로 성능 혁신이 일어나고 있습니다. 특히 내부 엔진을 Rust 기반의 **Rolldown**이나 **esbuild**로 교체하며 '압도적인 속도'를 지향하는 추세입니다. 우리가 직접 번들러를 만들어보며 ESM의 구조를 배우는 것은, 바로 이러한 차세대 도구들이 동작하는 근본 원리를 이해하는 과정이기도 합니다.

---

## 4. 구현의 핵심 1: 왜 ESM인가?

우리가 만들 번들러의 핵심 기반은 **ESM(ECMAScript Modules)**입니다. 이는 단순히 최신 기술이기 때문이 아니라, **정적 분석(Static Analysis)**이 가능하다는 강력한 이점 때문입니다.

### 정적 분석 vs 동적 실행

- **CJS (동적)**: `require`는 함수입니다. 즉, `if`문 안에서 조건에 따라 모듈을 불러올 수 있습니다. 코드를 실제로 실행해보기 전까지는 어떤 의존성이 필요한지 완벽하게 파악하기 어렵습니다.
- **ESM (정적)**: `import`는 파일의 최상위(Top-level)에서만 선언할 수 있는 정적인 구문입니다. 번들러는 코드를 실행하지 않고 텍스트만 읽어서도 모듈 간의 관계를 100% 확신할 수 있습니다. 이것이 바로 우리가 **의존성 그래프(Dependency Graph)**를 구축할 수 있는 기술적 토대가 됩니다.

### Live Binding: 참조의 마법

ESM의 또 다른 독특한 특징은 값을 복사하지 않고 **참조(Reference)**로 연결한다는 점입니다.

- **CJS**: 가져온 값은 그 시점의 **스냅샷**입니다. 원본이 바뀌어도 변하지 않습니다.
- **ESM**: 가져온 값은 원본을 가리키는 **실시간 통로**와 같습니다. 원본 모듈에서 값이 업데이트되면 이를 사용하는 모든 곳에 즉시 반영됩니다.

이러한 특성은 **순환 참조(Circular Dependency)** 문제를 우아하게 해결하며, 번들러가 더욱 정교하게 코드를 연결할 수 있게 해줍니다.

---

## 5. 구현의 핵심 2: 코드 조작의 마법사, Magic String

번들러의 본질은 "A 코드를 읽어서 조작한 뒤 B 코드로 내보내는 것"입니다. 여기서 `import` 문을 지우거나 변수명을 바꾸는 등의 '조작' 과정에서 예상치 못한 복병을 만나게 됩니다.

### 왜 일반적인 문자열 치환은 위험할까요?

1. **인덱스 밀림 현상**: 앞쪽 코드를 수정해 길이가 바뀌면 뒤쪽 모든 코드의 위치 정보가 틀어집니다.
2. **소스맵(SourceMap) 소실**: 변환된 결과물이 원본의 어느 위치에서 왔는지에 대한 정보가 사라져 디버깅이 불가능해집니다.

### Magic String의 해결책

그래서 우리는 `magic-string`이라는 라이브러리를 사용합니다. 이 도구는 문자열을 직접 수정하는 대신 **수정 명령(삭제, 삽입, 교체)을 기록**해두었다가 마지막에 한 번에 적용합니다.

```javascript
import MagicString from 'magic-string';

const s = new MagicString("export var name = 'antigravity';");

// "export var " 부분을 지우고
s.remove(0, 11);

// 값을 'antigravity'에서 'bundler'로 교체합니다.
s.overwrite(19, 30, 'bundler');

console.log(s.toString()); // name = 'bundler';
// 원본과의 연결 정보를 담은 소스맵도 자동으로 생성됩니다!
```

우리는 이 `Magic String`을 활용해 원본 소스 코드의 무결성을 유지하면서, 브라우저가 이해할 수 있는 하나의 번들 파일로 정교하게 재조립할 것입니다.

---

## 6. 실전: 10줄로 만드는 초미니 번들러

개념만 공부하고 넘어가기엔 손이 근질거리지 않나요? 앞서 배운 내용들을 종합해, 파일 하나를 읽어서 그대로 내보내는 세상에서 가장 단순한 번들러를 만들어보며 1단계를 마무리합시다.

```javascript
import fs from 'node:fs';
import MagicString from 'magic-string';

// 1. 파일 읽기 (모듈 해석 단계의 기초)
const content = fs.readFileSync('./src/index.js', 'utf-8');

// 2. MagicString으로 감싸기 (변환의 기초)
const bundle = new MagicString(content);

// 3. (가정) 여기서 코드를 분석하고 변환하는 작업이 들어갑니다.
bundle.prepend('/* Bundled by Me */\n');

// 4. 결과물 쓰기 (생성 단계)
fs.writeFileSync('./dist/bundle.js', bundle.toString());
console.log('Build completed!');
```

이 10줄 남짓한 코드가 바로 우리가 만들 거대한 번들러의 **아주 작은 씨앗(MVP)**입니다. 지금은 단순히 파일을 복사하는 수준이지만, 앞으로 우리는 저 3번 주석 자리에 **AST 분석, 의존성 그래프 탐색, 코드 변환 로직**을 하나씩 채워 넣을 것입니다.

---

이제 기초 체력은 충분히 길렀습니다. 다음 단계에서는 실제로 코드를 데이터로 변환하여 분석하는 **AST 분석과 의존성 그래프 구현**의 세계로 들어가 보겠습니다.
