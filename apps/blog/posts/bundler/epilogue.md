---
title: '에필로그: 우리가 만든 번들러, 그리고 남은 과제들'
date: 2026-01-11
tags: ['bundler', 'javascript', 'retrospective', 'rollup', 'webpack']
---

# 에필로그: 우리가 만든 번들러, 그리고 남은 과제들

"누가 시키지도 않았는데 라이브러리 번들러 만들기" 시리즈가 드디어 막을 내렸습니다. 빈 디렉토리에서 시작해 `fs.readFileSync`로 첫 파일을 읽었던 순간부터, 소스맵과 Externals를 고민하는 지금까지 꽤 긴 여정이었네요.

## 🏃‍♂️ 우리가 지나온 길 (Recap)

우리가 만든 미니 번들러는 현대적인 도구들이 수행하는 핵심 메커니즘을 모두 담고 있습니다.

1.  **Resolving**: 문자열 경로를 실제 파일 시스템의 절대 경로로 바꿉니다.
2.  **Parsing (AST)**: 코드를 컴퓨터가 이해하기 쉬운 트리 구조로 쪼개서 분석합니다.
3.  **Graph Construction**: 파일들 사이의 의존성 관계를 거대한 지도로 그립니다.
4.  **Transformation**: ESM 문법을 런타임에서 실행 가능한 구조로 변역합니다.
5.  **Bundling**: 모든 모듈을 함수 스코프로 감싸 하나로 합치고, 자체 `require` 시스템을 주입합니다.

이 도구로 우리는 실제 라이브러리를 빌드했고, Node.js와 브라우저 양쪽에서 동작하는 결과물을 만들어냈습니다.

## ⚠️ 현실의 벽: 우리가 구현하지 못한 것들

물론 우리가 만든 번들러는 학습용이기에 실제 서비스에 쓰기에는 부족한 점이 많습니다. 현대의 번들러들은 우리가 구현한 기초 위에 다음과 같은 고도화된 기술들을 쌓아 올렸습니다.

- **Tree Shaking (Deep Analysis)**: 우리는 단순히 파일을 합쳤지만, Rollup 같은 도구는 함수 단위로 분석해 사용되지 않는 코드를 완전히 제거합니다.
- **Code Splitting**: 모든 코드를 한 파일에 담는 대신, 필요한 시점에 동적으로 불러오는(`dynamic import`) 전략입니다.
- **HMR (Hot Module Replacement)**: 코드를 수정하면 페이지 새로고침 없이 바뀐 부분만 교체하는 마법 같은 기능입니다. 이는 복잡한 런타임 소켓 통신이 필요합니다.
- **Minification & Mangling**: 공백을 제거하고 변수 이름을 짧게 바꿔 용량을 극한으로 줄이는 최적화 과정입니다.

## ⚔️ Rollup vs Webpack: 철학의 차이

공부를 마친 지금, 다시 두 거인을 바라보면 그 차이가 더 명확히 보입니다.

- **Rollup**: 우리가 Step 4에서 고민했던 것처럼 '라이브러리 배포'에 최적화되어 있습니다. 코드를 펼쳐서(Scope Hoisting) 간결한 결과물을 내놓는 데 집중합니다.
- **Webpack**: '거대한 애플리케이션'을 관리하는 데 탁월합니다. 온갖 종류의 에셋(CSS, Image)을 모듈로 취급하고, 복잡한 로더와 플러그인 생태계를 통해 유연한 개발 환경을 제공합니다.

## 🎁 마치며: 왜 "바퀴를 다시 발명"했는가?

누군가는 물을지도 모릅니다. "이미 훌륭한 번들러가 많은데 왜 이런 수고를 하나요?"

그 질문에 대한 저의 답은 **"도구의 주인이 되기 위해서"**입니다. 번들러를 직접 만들어본 개발자는 빌드 에러 메시지 한 줄에서도 AST의 구조를 떠올리고, `node_modules`의 복잡한 의존성 속에서도 그래프의 흐름을 읽어낼 수 있습니다.

추상화의 레이어를 한 단계 벗겨내고 그 속을 들여다보는 경험은, 단순히 도구를 사용하는 법을 익히는 것과는 비교할 수 없는 단단한 기술적 자산이 됩니다.

이 시리즈가 여러분께 번들러라는 거대한 산을 정복하는 작은 지도이자 용기가 되었기를 바랍니다. 그동안 함께 해주셔서 감사합니다! 🚀
