---
title: '0. 프롤로그'
description: '번들러 내부 흐름을 직접 구현하며 라이브러리 번들링의 판단 과정을 기록하는 시리즈 시작.'
date: null
slug: 'no-one-asked-library-bundler-00-prologue'
published: false
tags: ['bundler', 'library', 'build', 'tooling']
excerpt: '도구가 대신 해주던 선택을 직접 내려보며 번들러의 내부 흐름을 이해해 봅니다.'
---

# 0. 프롤로그: 질문의 시작

> 이전에 작성한 [하루 만에 끝날 줄 알았던 디자인 시스템 배포가 3주 걸린 이유](https://velog.io/@rewq5991/npm-deploy-series-0-prologue)에서는  
> "패키지를 배포하는 과정" 자체에 집중했다면, 이번에는 그 배포물의 **생성 과정**을 파고들어 보려 합니다.  
> 배포는 끝났는데, 정작 결과물이 만들어지는 과정을 내가 제대로 이해하고 있는지 스스로 의문이 들었기 때문입니다.

---

## 시리즈의 출발점

**npm 배포 과정을 정리하면서 이런 질문이 남았습니다.**

- **소스 코드는 수십 개인데, 왜 결과물은 딱 하나로 합쳐질까? 그 경계는 누가, 어떤 기준으로 정할까?**
- **`package.json`의 `main/module/exports/sideEffects` 값은 번들러의 동작에 어떤 영향을 줄까? (남들이 하라는 대로 복사만 하던 이 값들의 실체는?)**
- **모든 의존성을 번들에 포함해야 할까? `external`과 `peerDependencies`는 어떤 기준으로 솎아내는 걸까?**
- **Tree Shaking은 실제로 코드를 실행해보지도 않고 어떻게 '안 쓰는 코드'를 확신하며 지워버릴까?**

이 시리즈는 그 질문에 직접 손으로 답해보는 실험입니다.  
**“누가 시키지도 않았는데”** 라이브러리 번들러를 만들어 보는 기록을 시작합니다.

## 무엇을 다룰까?

**최소 기능의 라이브러리 번들러를 직접 구현하며 핵심 흐름을 따라갑니다.**

- **모듈 해석(Resolve):** Node.js의 알고리즘을 따라 파일 경로를 찾는 규칙 구현
- **의존성 그래프:** `acorn` 파서를 이용해 AST를 분석하고 모듈 간의 관계도 그리기
- **변환(Transform):** `magic-string`을 활용해 코드를 래핑하고 ESM/CJS로 변환하기
- **출력(Generate):** 번들링된 결과물 생성 및 간단한 Tree Shaking(미사용 모듈 제외) 적용
- **부가 산출물:** Sourcemap의 원리 이해와 Line-to-Line 수준의 단순 구현

## 무엇을 다루지 않을까?

**이번 시리즈는 “실무에서 바로 쓸 도구”가 목적이 아닙니다.**

- 앱 번들링(Code Splitting, HMR, Dev Server 등)
- CSS/이미지 등 복잡한 에셋 처리 파이프라인
- 고도화된 성능 튜닝 및 플러그인 생태계 확장

## 이런 분들에게 추천합니다

**읽기 전에 10초 체크. 아래 중 2개 이상이면 딱 맞아요.**

- 번들러는 쓰지만 내부 흐름이 늘 블랙박스처럼 느껴진다
- 배포 산출물(ESM/CJS, export 구조)을 볼 때마다 헷갈린다
- "왜 이 파일이 포함됐지?"라는 생각이 자주 든다

**이 시리즈를 끝내면**

- 번들러의 판단 기준을 스스로 설명할 수 있습니다.
- 라이브러리 산출물을 의도대로 만들 수 있습니다

---

작은 단위로 쪼개어 구현하며, 핵심 단계마다 다이어그램으로 흐름을 정리하겠습니다.  
각 글은 **“왜 이 단계가 필요한지”** 와 **“어떤 판단을 내려야 하는지”** 에 집중합니다.

다음 글에서는 **번들링의 기본 개념**부터 정리해 보겠습니다.
