---
title: '[누가 시키지도 않았는데 라이브러리 번들러 만들기] 0. 프롤로그: 질문이 구현이 되는 순간'
description: '도구가 대신 해주던 선택을 직접 내려보며, 라이브러리 번들러의 내부 흐름을 바닥부터 구현해보는 시리즈를 시작합니다.'
date: '2026-01-11'
slug: 'no-one-asked-library-bundler-00-prologue'
published: false
tags: ['bundler', 'library', 'build', 'tooling', 'javascript']
excerpt: '수많은 소스 코드가 어떻게 하나의 결과물로 합쳐질까요? 당연하게 사용하던 번들러의 블랙박스를 열고, 직접 손으로 구현하며 그 답을 찾아봅니다.'
---

# 0. 프롤로그: 질문이 구현이 되는 순간

> 이전에 작성한 **[하루 만에 끝날 줄 알았던 디자인 시스템 배포가 3주 걸린 이유](https://velog.io/@rewq5991/npm-deploy-series-0-prologue)** 에서는 "패키지를 배포하는 과정" 그 자체에 집중했습니다.  
> 이번에는 시선을 조금 더 안쪽으로 돌려보려 합니다. 바로 배포물이 만들어지는 **생성 과정** 입니다.

배포는 성공적으로 마쳤지만, 정작 결과물이 어떤 원리로 만들어지는지 제대로 이해하지 못한 채 도구에만 의존하고 있다는 의문이 들었습니다. **"남들이 다 쓰니까"**, **"이게 표준이라니까"** 라며 무심코 넘겼던 설정값들이 실제로는 번들러 내부에서 어떤 판단을 내리게 만드는 걸까요?

---

## 🚀 시리즈의 출발점: 당연한 것에 던지는 질문

npm 배포 과정을 정리하면서 머릿속을 떠나지 않았던 질문들이 있습니다.

- **결합의 원리**: 소스 코드는 수십 개인데, 왜 결과물은 딱 하나로 합쳐질까요? 그 경계는 누가, 어떤 기준으로 정하는 걸까요?
- **설정의 실체**: `package.json`의 `main`, `module`, `exports`, `sideEffects` 값들은 번들러의 동작에 어떤 물리적인 영향을 줄까요?
- **의존성의 선별**: 모든 의존성을 번들에 포함해야 할까요? `external`과 `peerDependencies`는 어떤 기준으로 솎아내는 것일까요?
- **트리 쉐이킹(Tree Shaking)**: 코드를 직접 실행해보지도 않고, 어떻게 '사용하지 않는 코드'라고 확신하며 지워버릴 수 있을까요?

이 시리즈는 이러한 질문들에 대해 이론적인 답변을 찾는 대신, **직접 손으로 구현하며 몸소 답을 찾아가는 실험 기록**입니다. **“누가 시키지도 않았지만”** 라이브러리 번들러를 직접 만들어보며 그 블랙박스를 열어보려 합니다.

## 💡 "Vite 쓰면 1초면 되는데...?" (이걸 왜 만드나요?)

"요즘 세상에 누가 웹팩 설정을 직접 만지나요? 그냥 `npm create vite` 하면 끝인데."
맞습니다. 우리는 레이저 커터(Vite, Turbopack)가 있는 시대에 살고 있습니다. 하지만 굳이 돌도끼(직접 만든 번들러)를 깎아보는 이유는 **"도구에 잡아먹히지 않기 위해서"** 입니다.

이 과정을 통해 여러분은 **'실무적 초능력'** 3가지를 얻게 됩니다.

1.  **에러 메시지를 투시하는 능력 (Debugging)**
    - `Uncaught ReferenceError`, `Module not found` 에러를 만났을 때, 번들러가 그래프를 그리는 과정(AST, Resolve)을 알면 원인이 머릿속에 투시도처럼 그려집니다.
2.  **'트리 쉐이킹 친화적'인 코드 작성 (Optimization)**
    - 왜 `export default`보다 `Named Export`가 유리한지, `sideEffects: false`가 정확히 어떤 동작을 끄는 것인지, 이론이 아닌 구현 레벨에서 이해하게 됩니다.
3.  **차세대 도구에 대한 적응력 (Adaptability)**
    - Vite(Rolldown), Next.js(Turbopack) 등 도구의 이름은 바뀌어도, **Parsing → Graph → Linking**이라는 본질적인 아키텍처는 변하지 않습니다.

## 🛠️ 무엇을 다룰까요?

우리는 아주 최소한의 기능을 가진 '라이브러리 전용 번들러'를 구현하며 핵심 흐름을 따라갑니다.

- **모듈 해석(Resolve)**: Node.js의 알고리즘을 따라 파일 경로를 찾는 규칙을 직접 구현합니다.
- **의존성 그래프(Dependency Graph)**: `acorn` 파서를 이용해 AST(Abstract Syntax Tree)를 분석하고 모듈 간의 유기적인 관계를 그려냅니다.
- **변환(Transform)**: `magic-string`을 활용해 코드를 래핑하고, ESM과 CJS 형식으로 변환하는 과정을 거칩니다.
- **출력(Generate)**: 번들링된 결과물을 생성하고, 기초적인 수준의 트리 쉐이킹(미사용 모듈 제외)을 적용해봅니다.
- **소스맵(Sourcemap)**: 소스맵의 기본 원리를 이해하고, Line-to-Line 수준의 단순한 구현을 시도합니다.

## ⚠️ 무엇을 다루지 않을까요?

이번 시리즈의 목적은 "실무에서 바로 사용할 수 있는 고성능 도구"를 만드는 것이 아닙니다. 따라서 다음의 복잡한 주제들은 과감히 생략합니다.

- **애플리케이션 번들링**: Code Splitting, HMR(Hot Module Replacement), 개발 서버 구현 등
- **에셋 파이프라인**: CSS, 이미지, 폰트 등 자바스크립트 외의 에셋 처리
- **고도화된 최적화**: 성능 튜닝, 복잡한 플러그인 생태계 구축

## 🎯 이런 분들께 추천합니다

읽기 전에 잠시 체크해보세요. 아래 항목 중 2개 이상 해당한다면 이 시리즈가 분명 도움이 될 것입니다.

- [ ] 번들러를 매일 사용하지만 내부 동작 방식은 늘 안갯속처럼 느껴진다.
- [ ] 라이브러리 산출물(ESM/CJS, export 구조)을 볼 때마다 설정값이 헷갈린다.
- [ ] "왜 이 파일이 최종 번들에 포함됐지?"라는 의문이 자주 든다.
- [ ] 기술의 원리를 파악할 때 '직접 만들어보는 것'을 선호한다.

**이 시리즈를 마칠 때쯤이면 여러분은:**

1. 번들러의 판단 기준을 자신의 언어로 설명할 수 있게 됩니다.
2. 라이브러리 산출물을 의도한 대로 설계하고 제어할 수 있습니다.

---

모든 과정은 작은 단위로 쪼개어 진행하며, 핵심 단계마다 직관적인 다이어그램으로 흐름을 정리하겠습니다. 각 글은 단순히 "어떻게 코드를 짰는지"를 넘어, **“왜 이 단계가 필요한지”** 와 **“어떤 기술적 판단을 내렸는지”** 에 집중합니다.

준비되셨나요? 다음 글에서는 **번들링의 기본 개념과 역사**부터 차근차근 짚어보겠습니다.
