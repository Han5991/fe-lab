---
title: '[누가 시키지도 않았는데 라이브러리 번들러 만들기] 1. 개념과 도구: 번들러가 태어난 이유'
description: '스크립트 태그의 지옥에서 ESM까지, 번들러가 필요해진 역사적 배경과 우리가 사용할 핵심 도구(Magic String)를 알아봅니다.'
date: '2026-02-02'
slug: 'no-one-asked-library-bundler-01-concept'
thumbnail: 'bundler-concept-thumb.png'
published: true
tags: ['bundler', 'javascript', 'history', 'esm', 'magic-string']
excerpt: '왜 우리는 코드를 하나로 합쳐야 할까요? 자바스크립트 모듈 시스템의 역사와 번들러 구현을 위한 강력한 무기, Magic String을 소개합니다.'
---

# 1. 개념과 도구: 번들러가 태어난 이유

> **"그냥 HTML에 `<script>` 태그 여러 개 쓰면 안 되나요?"**

개발을 처음 시작할 때 한 번쯤 해보는 생각입니다. 파일이 늘어나면 태그를 늘리면 되고, 라이브러리가 필요하면 CDN 링크를 복사해 넣으면 그만 아닌가? 왜 굳이 '빌드'라는 복잡한 과정을 거쳐야 할까요?

이 질문에 답하려면 시계를 조금 뒤로 돌려봐야 합니다. 자바스크립트가 아직 '장난감 언어' 취급을 받던 시절로 말이죠.

---

## 🕰️ 모듈 시스템의 흑역사 (그리고 진화)

### 1. 전역 스코프(Global Scope)의 지옥

초기의 자바스크립트는 파일을 나누는 기준이 모호했습니다. `a.js`에서 선언한 변수는 `b.js`에서도 접근할 수 있었죠. 이게 편해 보이지만, 실제로는 재앙이었습니다.

```html
<script src="jquery.js"></script>
<script src="slider.js"></script>
<script src="main.js"></script>
```

만약 `slider.js`와 `main.js`가 우연히 같은 이름의 변수(`var index = 0`)를 쓴다면? 나중에 로드된 파일이 앞의 변수를 덮어버립니다. 이를 막기 위해 개발자들은 변수명에 `_`를 붙이거나 네임스페이스 객체를 만드는 눈물겨운 사투를 벌였습니다.

### 2. IIFE (즉시 실행 함수) - 스스로 감옥 만들기

이 문제를 해결하기 위해 등장한 것이 **IIFE(Immediately Invoked Function Expression)** 패턴입니다.

```javascript
(function () {
  var privateVar = 'I am safe';
  window.MyModule = {
    sayHello: function () {
      console.log(privateVar);
    },
  };
})();
```

함수 스코프를 이용해 변수를 가두고, 필요한 것만 `window`에 노출하는 방식입니다. 우리가 Step 3에서 구현할 번들링 결과물도 바로 이 패턴을 사용합니다. (가장 원시적이지만 가장 확실한 격리 방법이기 때문이죠.)

### 3. CommonJS - 혁명, 하지만 반쪽짜리

2009년, Node.js가 등장하면서 상황이 바뀝니다. **"파일이 곧 모듈이다"** 라는 개념이 확립된 것이죠.

```javascript
// math.js
const add = (a, b) => a + b;
module.exports = add;

// main.js
const add = require('./math');
console.log(add(1, 2));
```

혁명적이었습니다. 하지만 치명적인 단점이 있었으니, **브라우저는 `require`를 모른다**는 것이었습니다. 게다가 `require`는 동기 방식으로 동작해서, 파일을 다 읽을 때까지 브라우저가 멈춰버릴 위험이 있었습니다.

### 4. ESM (ECMAScript Modules) - 드디어 표준이 되다

오랜 혼란 끝에 2015년(ES6), 자바스크립트 공식 모듈 시스템인 **ESM**이 등장합니다.

```javascript
import { add } from './math.js';
export { add };
```

이제 브라우저도 `<script type="module">`을 통해 모듈을 이해합니다. 그럼 이제 번들러는 필요 없는 걸까요?

---

## 🏗️ 왜 아직도 번들러가 필요한가?

Vite나 Webpack 같은 번들러가 여전히 필수인 이유는 크게 두 가지입니다.

1.  **성능**:
    브라우저가 ESM을 지원한다 해도, 파일이 100개라면 HTTP 요청도 100번 발생합니다. 네트워크 오버헤드는 여전히 큽니다. 파일을 하나(혹은 몇 개)로 합치는 '번들링'은 여전히 가장 강력한 최적화 수단입니다.

2.  **생태계의 파편화**:
    npm에 있는 수많은 라이브러리는 여전히 CJS로 작성되어 있습니다. 브라우저에서 바로 돌릴 수 없는 이 코드들을 해석하고 변환해주는 '통역사'가 필요합니다.

우리가 만들 번들러는 바로 이 **"흩어진 파일들을 찾아서(Resolve), 순서를 정하고(Graph), 하나로 합치는(Bundle)"** 역할을 수행합니다.

---

## ⚔️ 우리의 무기 1: ESM (정적 분석의 힘)

우리는 번들러를 만들 때 **ESM 문법을 기반**으로 할 것입니다. 왜냐고요?

CommonJS(`require`)는 동적입니다.

```javascript
if (Math.random() > 0.5) {
  require('./a.js'); // 실행해봐야 아는 의존성
}
```

반면 ESM(`import`)은 정적입니다.

```javascript
import { a } from './a.js'; // 무조건 파일 최상단!
```

코드를 실행하지 않아도 **"이 파일이 누구랑 연결되어 있는지"** 100% 확신할 수 있습니다. 이것이 바로 **트리 쉐이킹** 이 가능한 이유이며, 우리가 만들 번들러가 복잡한 실행기 없이도 의존성 그래프를 그릴 수 있는 비결입니다.

---

## 🪄 우리의 무기 2: Magic String

번들러를 구현한다는 건 결국 **"코드를 읽어서 문자열을 조작하는 일"** 입니다.
`import`를 지우고, 변수명을 바꾸고, 코드를 합쳐야 하죠.

보통 문자열을 바꿀 때 `String.prototype.replace`를 생각하기 쉽습니다. 하지만 코드 조작에서는 이게 지옥의 문을 엽니다.

### ❌ 단순 replace의 문제점

문자열을 한번 수정하면 전체 길이가 바뀝니다. 즉, **인덱스가 밀립니다.**

```javascript
const code = "import { a } from './a.js'; console.log(a);";
// 앞부분 import를 지우면, 뒤에 있는 'console.log'의 위치(인덱스)를 다시 계산해야 함.
// 수정할 곳이 100군데라면? 인덱스 계산하다가 끝남.
```

### ✅ Magic String의 마법

`magic-string` 라이브러리는 이 문제를 우아하게 해결합니다.

```javascript
import MagicString from 'magic-string';

const s = new MagicString('export const a = 1;');

// 인덱스는 원본 기준! 순서 상관없이 조작 가능
s.overwrite(0, 6, 'const'); // export -> const

console.log(s.toString()); // "const const a = 1;" (예시)
```

가장 중요한 건 **소스맵** 입니다. 우리가 코드를 제아무리 뒤죽박죽 섞어도, `s.generateMap()` 한 방이면 원본 코드의 위치를 가리키는 소스맵을 만들어줍니다. 이게 없으면 나중에 디버깅할 때 번들링된 코드만 보고 울게 될지도 모릅니다.

---

## 🚀 준비 완료

자, 이제 배경지식과 도구는 준비되었습니다.
우리의 목표는 명확합니다.

1.  파일을 읽는다.
2.  `import` 문을 찾는다. (**Parsing**)
3.  그 파일도 읽는다. (**Graph**)
4.  하나로 합친다. (**Bundle**)

다음 Step부터는 실제 코드를 작성하며, 첫 번째 난관인 **"파일을 읽어서 데이터를 뽑아내는 과정(AST)"** 을 정복해보겠습니다.

**[Step 2. 그래프 그리기 (Resolve & AST) 로 이동]** `Coming Soon`
