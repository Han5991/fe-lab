# 3주간의 패키지 배포 삽질기 - 발표 스크립트
## 완벽을 포기하고 배운 것들

**총 발표 시간**: 30분
**타임라인**: 오프닝(3분) → 본론(20분) → 결론(5분) → 여유(2분)

---

## 📌 발표 전 체크리스트

- [ ] 슬라이드 파일 준비
- [ ] 노트북 및 프로젝터 연결 테스트
- [ ] 백업용 PDF 준비
- [ ] 리모컨/클리커 작동 확인
- [ ] 물 준비
- [ ] 타이머 설정 (28분 알람)

---

## Part 0: 오프닝 (3분)

---

### 슬라이드 1: 타이틀 (30초)

**[슬라이드 표시]**

안녕하세요. 오늘은 제가 3주간 디자인 시스템을 NPM 패키지로 배포하면서 겪었던 삽질기를 공유하려고 합니다.

부제가 "완벽을 포기하고 배운 것들"인데요, 특히 '완벽'을 추구하다가 어떻게 현실과 타협했는지에 대한 이야기입니다.

**[다음 슬라이드로]**

---

### 슬라이드 2: 시작점 (1분)

**[슬라이드 표시]**

이야기는 이렇게 시작됩니다.

타팀 기획자가 다가와서 "저희 팀에서도 그 디자인 시스템 쓸 수 있을까요?"라고 물어봤습니다.

당시 저는 자신만만했습니다. "별거 아니에요. NPM에 올리기만 하면 되니까 하루면 될 것 같은데요?"

**[잠시 멈춤, 청중 응시]**

그때의 저에게 말해주고 싶습니다.

**[강조하며]** "별거 아닌 일은 없다"고.

**[다음 슬라이드로]**

---

### 슬라이드 3: 처음 세운 완벽한 계획 (1분)

**[슬라이드 표시]**

제가 처음 세운 계획입니다.

**[하나씩 가리키며]**

1번, 완벽한 트리쉐이킹과 미니멀한 번들 사이즈
2번, 완벽한 트리쉐이킹 가능한 CSS 번들
3번, 완벽한 Type 지원
4번, 완벽한 배포 및 설치 문서
5번, 완벽한 자동 배포 시스템

목표는 300KB 이하의 가벼운 번들, 완벽한 타입 지원, 자동화된 배포 시스템...

**[자신감 있게]** 완벽해 보이죠?

이 모든 걸 하루 이틀이면 할 수 있을 거라고 생각했습니다.

**[다음 슬라이드로]**

---

### 슬라이드 4: 3주 후의 현실 (30초)

**[슬라이드 표시]**

3주 후...

**[천천히]** 제 앞에는 20MB짜리 괴물 패키지가 있었습니다.

목표의 66배입니다.

**[잠시 멈춤]**

하지만 중요한 건, 이게 실제로 작동했다는 겁니다.

오늘은 이 여정에서 제가 무엇을 포기했고, 왜 포기했으며, 무엇을 배웠는지 이야기하겠습니다.

**[다음 슬라이드로]**

---

## Part 1: 본론 - 포기의 여정 (20분)

---

### 슬라이드 5: 섹션 타이틀 (10초)

**[슬라이드 표시]**

포기의 여정입니다.

하나씩 체크박스를 지워가며 진행하겠습니다.

**[다음 슬라이드로]**

---

### 슬라이드 6-9: 포기 #1 - 번들 사이즈 (4분)

**[슬라이드 6 표시]**

첫 번째 포기.

완벽한 트리쉐이킹과 미니멀한 번들 사이즈입니다.

**[다음 슬라이드로]**

---

**[슬라이드 7 표시]**

왜 20MB가 되었을까요?

**[구조를 가리키며]**

패키지 안에 소스코드 전체, styled-system 전체, node_modules 일부, 그리고 모든 정적 자산까지... 모든 게 다 들어가 있었습니다.

왜냐하면, Panda CSS의 특성상 런타임에 스타일을 생성하려면 styled-system 전체가 필요했고, 결국 소스코드를 통째로 넣는 방법밖에 없었습니다.

**[다음 슬라이드로]**

---

**[슬라이드 8 표시]**

물론 포기하기 전에 여러 방법을 시도했습니다.

**[하나씩 설명]**

Panda CSS 공식 문서의 buildInfo를 써봤지만 동작하지 않았고,

빌드 시 CSS를 추출하려 했지만 필요한 클래스가 전부 생성되지 않았습니다.

dist 폴더만 배포하니 런타임 에러가 발생했습니다.

**[다음 슬라이드로]**

---

**[슬라이드 9 표시]**

결국 내린 결정은 '소스코드를 통째로 배포'하는 것이었습니다.

**[exports 부분을 가리키며]**

보시다시피 exports를 dist가 아닌 src로 설정했습니다.

**[장단점을 가리키며]**

장점은 Panda CSS 함수가 런타임에 호출 가능하고, 타입 정보도 함께 제공되며, 실제로 작동한다는 것입니다.

단점은... 20MB라는 것과 설치 시간이 증가한다는 겁니다.

**[강조하며]** 하지만 완벽하진 않지만, 작동합니다.

그리고 이게 당장 팀이 사용할 수 있는 유일한 방법이었습니다.

**[다음 슬라이드로]**

---

### 슬라이드 10-13: 포기 #2 - CSS 번들 (5분)

**[슬라이드 10 표시]**

두 번째 포기.

완벽한 트리쉐이킹 가능한 CSS 번들입니다.

**[다음 슬라이드로]**

---

**[슬라이드 11 표시]**

Panda CSS는 런타임에 스타일을 생성하는 방식입니다.

**[코드를 가리키며]**

이렇게 css 함수를 호출할 때 런타임에 클래스가 생성되기 때문에, 정적으로 번들링하기가 매우 어렵습니다.

그래서 styled-system 전체 폴더, Panda 함수들, 토큰 정의... 이 모든 게 필요합니다.

**[다음 슬라이드로]**

---

**[슬라이드 12 표시]**

그리고 더 큰 문제가 있었습니다.

실제 사용 환경이 Remix + Tailwind였는데,

**[기존 프로젝트 부분 강조]**

기존 CSS가 !important로 도배되어 있어서 우리 스타일이 전부 덮어씌워졌습니다.

**[우리 디자인 시스템 부분 가리키며]**

Mantine과 Panda CSS를 사용하는 우리 디자인 시스템이 전혀 보이지 않았습니다.

**[다음 슬라이드로]**

---

**[슬라이드 13 표시]**

이 문제는 CSS Layer로 해결했습니다.

**[코드 설명]**

먼저 @layer로 우선순위를 명시적으로 선언하고,

**[import 부분 가리키며]**

@import의 layer() 함수로 외부 CSS를 원하는 위치에 배치했습니다.

**[강조하며]** 이게 유일하게 제대로 동작한 해결책이었습니다.

!important 없이도 우선순위를 제어할 수 있게 됐습니다.

**[다음 슬라이드로]**

---

### 슬라이드 14-16: 포기 #3 - Type 지원 (3분)

**[슬라이드 14 표시]**

세 번째 포기.

완벽한 Type 지원입니다. SVGR과 tsup의 전쟁이었습니다.

**[다음 슬라이드로]**

---

**[슬라이드 15 표시]**

우리는 SVGR로 SVG를 컴포넌트로 변환하고 있었는데,

**[코드의 export default 부분 강조]**

tsup이 SVGR의 default export 구문을 처리하지 못했습니다.

**[에러 메시지 가리키며]** 계속 이런 에러가 발생했습니다.

**[다음 슬라이드로]**

---

**[슬라이드 16 표시]**

결국 타협한 방법은 이중 빌드 시스템입니다.

**[scripts 부분 설명]**

tsup으로 번들링하고, tsc를 따로 돌려서 타입 정의 파일을 생성하는 방식입니다.

**[결과 부분 가리키며]**

완벽하진 않지만 대부분의 타입은 지원됩니다. SVG 관련 타입은 일부 누락되어 있습니다.

**[다음 슬라이드로]**

---

### 슬라이드 17-18: 포기 #4 - 문서 (3분)

**[슬라이드 17 표시]**

네 번째 포기.

완벽한 배포 및 설치 문서입니다.

**[솔직하게]** 시간이 부족했습니다.

**[다음 슬라이드로]**

---

**[슬라이드 18 표시]**

**[현실 부분 가리키며]**

시간도 부족했고, 우선순위에서도 밀렸고, 사용자가 한 팀뿐이었습니다.

그래서...

**[해결책 부분 설명]**

직접 연락하고, 슬랙으로 가이드하고, 필요하면 페어 프로그래밍을 했습니다.

**[웃으며]** 일단 확실한 방법부터 쓰기로 했습니다.

초기 사용자가 한 팀뿐이어서, 직접 가이드하는 게 오히려 더 효율적이었습니다.

완벽한 문서보다 빠른 피드백이 중요했습니다.

**[다음 슬라이드로]**

---

### 슬라이드 19-20: 성공 #5 - 자동 배포 (5분)

**[슬라이드 19 표시]**

다섯 번째.

**[힘주어]** 완벽한 자동 배포 시스템 구축. 이건 해냈습니다!

**[다음 슬라이드로]**

---

**[슬라이드 20 표시]**

유일하게 완벽히 성공한 TODO입니다.

**[구축한 시스템 부분 설명]**

Changeset으로 버전을 자동 관리하고, GitHub Actions로 자동 배포하고, CHANGELOG도 자동으로 생성되고, npm에도 자동으로 퍼블리시됩니다.

**[잠시 멈춤]**

물론 여기도 쉽지만은 않았습니다.

**[문제들 하나씩 설명]**

npm scope 규칙 때문에 패키지 이름을 전체 변경해야 했고,

GitHub Actions가 무한 재귀에 빠지기도 했고,

토큰 권한 문제도 있었고,

기존 워크플로우와 충돌도 일어났습니다.

**[해결 부분 가리키며]**

하지만 paths-ignore를 설정하고 워크플로우를 분리해서 결국 해결했습니다.

**[강조하며]** 이건 완벽하게 성공했습니다.

**[다음 슬라이드로]**

---

## Part 2: 결론 (5분)

---

### 슬라이드 21: 최종 결과 (1분)

**[슬라이드 표시]**

최종 결과입니다.

**[체크리스트를 가리키며 하나씩]**

완벽한 트리쉐이킹 - 취소선. 20MB로 타협했습니다.

완벽한 CSS 번들 - 취소선. 소스코드 배포로 타협했습니다.

완벽한 Type 지원 - 취소선. 부분 지원으로 타협했습니다.

완벽한 문서 - 취소선. 육성과 슬랙으로 타협했습니다.

완벽한 자동 배포 - 체크! 이건 성공했습니다.

**[잠시 멈춤, 청중 응시]**

**[결과 부분 강조하며]**

5개 중 4개를 포기했습니다.

하지만 가장 중요한 것을 얻었습니다.

**[강조]** 바로 '팀이 실제로 사용할 수 있는 패키지'입니다.

**[다음 슬라이드로]**

---

### 슬라이드 22: 핵심 교훈 (1분 30초)

**[슬라이드 표시]**

이 과정에서 배운 것들입니다.

**[1번 가리키며]**

첫째, 완벽보다 실행입니다.

일단 돌아가게 만들고, 그 다음에 개선하면 됩니다.

**[2번 가리키며]**

둘째, 현실적 타협입니다.

팀 상황에 맞는 선택이 최선의 선택입니다.

**[3번 가리키며]**

셋째, 점진적 개선입니다.

한 번에 완벽할 순 없습니다.

**[잠시 멈춤]**

**[가장 중요한 교훈 부분 강조]**

그리고 가장 중요한 교훈.

**[힘주어]** "별거 아닌 일은 없다"

**[다음 슬라이드로]**

---

### 슬라이드 23: 최적화 로드맵 (1분)

**[슬라이드 표시]**

물론 여기서 끝이 아닙니다.

20MB를 300KB로 줄이는 로드맵을 가지고 있습니다.

**[계획 하나씩 가리키며]**

트리쉐이킹 가능한 구조로 리팩토링하고,

SVG를 별도 패키지로 분리하고,

불필요한 정적 자산을 제거하고,

Panda buildInfo에 재도전하고,

문서도 자동화할 계획입니다.

**[강조하며]**

하지만 이건 팀이 패키지를 사용하면서, 실제 피드백을 받으며 점진적으로 개선할 겁니다.

**[마지막 문구 가리키며]** 완벽은 한 번에 오지 않으니까요.

**[다음 슬라이드로]**

---

### 슬라이드 24: 다음에는 이렇게 (1분)

**[슬라이드 표시]**

다음에 또 패키지를 배포한다면, 이런 체크리스트를 사용할 겁니다.

**[빠르게 훑으며]**

사전 계획 단계에서는 npm scope 규칙 확인, CSS 프레임워크 조합 검증...

개발 단계에서는 pnpm pack으로 로컬 테스트 환경 먼저 구축...

적용 단계에서는 실제 환경과 유사한 테스트...

**[최적화 부분 강조]**

그리고 최적화는... 일단 돌아가게 만들기 우선입니다.

**[강조]** 이건 꼭 기억하겠습니다.

**[다음 슬라이드로]**

---

### 슬라이드 25: 클로징 (30초)

**[슬라이드 표시]**

마지막으로.

**[힘주어]** "별거 아니라고 하지 마세요!"

**[천천히]**

3주간의 삽질을 통해 배운 가장 큰 교훈은, 완벽한 해결책은 없다는 것입니다.

중요한 건 팀 상황에 맞는 현실적인 선택을 하는 것입니다.

**[잠시 멈춤, 청중 응시]**

이 발표가 여러분의 삽질을 줄여주길 바랍니다.

**[미소]** 감사합니다.

**[박수 기다림]**

---

## Q&A 대응 가이드

### 예상 질문 1: "왜 처음부터 tsup 대신 다른 도구를 안 썼나요?"

**답변**:
좋은 질문입니다. 당시에는 tsup이 가장 최신이고 TypeScript 타입을 동시에 지원한다는 평이 많았습니다.

하지만 지금 돌이켜보면 esbuild로 직접 설정하거나, Rollup을 사용하는 게 더 나았을 수도 있습니다.

다만 중요한 건, 도구 선택보다는 '요구사항을 정확히 파악하고 검증하는 것'이었다는 점입니다.

SVGR 처리가 필수였다면, 사전에 빌드 도구의 제약사항을 조사했어야 했습니다.

---

### 예상 질문 2: "20MB는 너무 큰 것 같은데, 실제 사용에 문제가 없나요?"

**답변**:
솔직히 말씀드리면, 이상적이진 않습니다.

하지만 우리 상황에서는 다음과 같은 이유로 수용 가능했습니다:

첫째, 내부 팀에서만 사용하기 때문에 네트워크 비용이 크지 않았습니다.

둘째, 설치는 한 번만 하면 되고, 그 이후엔 캐싱됩니다.

셋째, 가장 중요한 건 '작동한다'는 것이었습니다.

물론 지금은 최적화 로드맵을 가지고 단계적으로 개선하고 있습니다.

300KB까지는 못 가더라도 5MB 정도로는 줄일 수 있을 것 같습니다.

---

### 예상 질문 3: "CSS Layer를 몰랐는데, 어떻게 발견하셨나요?"

**답변**:
처음엔 PostCSS 설정으로 해결하려고 했는데 계속 실패했습니다.

그래서 "CSS specificity control", "Tailwind Mantine conflict" 같은 키워드로 계속 검색했습니다.

그러다가 CSS Cascade Layers라는 스펙을 알게 됐고, 이게 정확히 우리가 필요한 거였습니다.

**[팁 추가]** 스타일 충돌 문제가 있다면, CSS Layer를 꼭 검토해보시길 추천합니다.

특히 여러 CSS 프레임워크를 함께 사용할 때 정말 유용합니다.

---

### 예상 질문 4: "팀 내에서 반발은 없었나요? 20MB 패키지를..."

**답변**:
**[웃으며]** 솔직히 말씀드리면, 처음엔 좀 있었습니다.

하지만 두 가지로 설득했습니다:

첫째, 대안이 없었습니다. 완벽한 패키지를 만들려다 2주를 더 쓸 수는 없는 상황이었습니다.

둘째, 점진적 개선 로드맵을 명확히 제시했습니다. "일단 쓰면서 개선하자"는 합의를 이끌어냈습니다.

**[강조]** 그리고 가장 중요한 건, 실제로 작동하는 걸 보여줬다는 겁니다.

데모를 돌려보니 다들 "일단 이거 쓰고 개선하자"고 동의했습니다.

---

### 예상 질문 5: "지금까지 최적화는 어느 정도 진행됐나요?"

**답변**:
현재는 아직 20MB 상태입니다.

**[솔직하게]** 팀에서 사용하면서 다른 우선순위 높은 이슈들이 생겼고, 최적화는 조금 밀렸습니다.

하지만 최근에 사용하지 않는 폰트 파일과 SVG들을 제거해서 15MB 정도로 줄였습니다.

다음 스프린트에서는 컴포넌트별로 개별 import 가능하도록 구조를 바꿀 예정입니다.

**[중요한 포인트]** 이게 바로 '점진적 개선'의 현실입니다.

완벽하지 않아도 작동하니까, 사용하면서 천천히 개선할 수 있습니다.

---

### 예상 질문 6: "Mantine + Panda CSS 조합을 추천하시나요?"

**답변**:
**[신중하게]** 상황에 따라 다릅니다.

우리는 리소스 부족 상황에서 빠르게 구현해야 했고, Tailwind를 싫어하는 팀원들이 많아서 이 조합을 선택했습니다.

하지만 만약 다시 선택한다면...

**[솔직하게]** Remix + Tailwind 환경에 배포할 거였으면, 처음부터 Tailwind + shadcn/ui 같은 조합을 고려했을 것 같습니다.

CSS 프레임워크 조합은 배포 환경을 반드시 고려해야 합니다.

**[중요]** 사전에 프로토타입으로 검증하는 게 가장 중요합니다.

---

### 예상 질문 7: "pnpm pack 외에 다른 로컬 테스트 방법은 없나요?"

**답변**:
물론 있습니다!

**pnpm link** 나 **npm link**도 사용할 수 있습니다.

하지만 제 경험상 pnpm pack이 가장 실제 배포 환경과 유사했습니다.

왜냐하면:
- link는 심볼릭 링크라 빌드 결과물이 아닌 소스를 참조할 수 있고
- pack은 실제 배포될 파일만 포함되기 때문입니다

**[팁]** Verdaccio 같은 로컬 npm 레지스트리를 사용하는 방법도 있지만,
초기 테스트에는 pnpm pack이 가장 빠르고 간단합니다.

---

### 예상 질문 8: "3주가 너무 긴 것 같은데, 어디서 시간을 가장 많이 썼나요?"

**답변**:
**[체크하며]** 시간 배분을 보면:

- 빌드 시스템 구축: 약 5일
- CSS 충돌 해결: 약 7일 (가장 오래 걸림)
- 배포 자동화: 약 4일
- 타입 문제 해결: 약 2일
- 기타 (scope 변경, 테스트 등): 약 3일

**[강조]** CSS Layer를 몰라서 7일을 허비했습니다.

만약 처음부터 알았다면 2주 정도로 줄일 수 있었을 겁니다.

**[교훈]** 그래서 사전 조사가 중요합니다.

CSS 프레임워크 조합 문제를 사전에 검색하고 프로토타입으로 검증했다면...

---

## 발표 후 행동 가이드

### 발표 직후
1. 청중 질문에 성실히 답변
2. 슬랙/이메일 연락처 공유
3. 발표 자료 공유 약속

### 발표 다음 날
1. 발표 자료 블로그 포스팅
2. 추가 질문 대응
3. 피드백 정리

### 1주일 후
1. 후기 작성
2. 개선 사항 반영
3. 다음 발표 계획

---

## 📌 비상 대응 가이드

### 시간이 부족할 경우
- 슬라이드 8, 15, 18, 24는 빠르게 넘어가도 됨
- 백업 슬라이드는 생략
- Q&A 시간 줄이기

### 시간이 남을 경우
- 슬라이드 7, 13, 20에서 더 상세히 설명
- 백업 슬라이드 활용
- 추가 질문 유도

### 프로젝터 문제
- 백업 PDF 준비
- 스크립트만으로도 발표 가능하도록 준비
- 핵심 메시지는 암기

### 갑작스러운 질문
- "좋은 질문입니다" (시간 벌기)
- "제 경험상..." (개인 경험으로 답변)
- "확실하지 않으면 확인 후 답변드리겠습니다" (솔직함)

---

## 🎯 핵심 메시지 (잊지 말 것)

1. **완벽보다 실행**
2. **현실적 타협**
3. **점진적 개선**
4. **별거 아닌 일은 없다**

---

## 성공적인 발표를 위한 마지막 팁

1. **속도 조절**: 긴장하면 빨라지니 의식적으로 천천히
2. **청중 응시**: 노트북만 보지 말고 청중과 아이컨택
3. **강약 조절**: 중요한 부분은 톤과 속도로 강조
4. **실수 대응**: 실수해도 당황하지 말고 자연스럽게 넘어가기
5. **에너지**: 지치지 말고 끝까지 에너지 유지

**당신은 3주간 삽질한 전문가입니다. 자신감을 가지세요!** 🚀