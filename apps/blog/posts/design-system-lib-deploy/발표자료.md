# 3주간의 패키지 배포 삽질기

## 완벽을 포기하고 배운 것들

**발표 시간**: 30분 (Q&A 별도)
**발표자**: [이름]
**날짜**: [날짜]

---

## 슬라이드 1: 타이틀

# 3주간의 패키지 배포 삽질기

## 완벽을 포기하고 배운 것들

> 20MB 괴물을 만들고 배운 것

---

## 슬라이드 2: 프롤로그

### "별거 아니겠지"의 착각

> **타팀 기획자**: "저희 팀에서도 그 디자인 시스템 쓸 수 있을까요?"
>
> **나**: "별거 아니에요. NPM에 올리기만 하면 되니까
> 하루면 될 것 같은데요?"

**[3주 후...]**

---

## 슬라이드 3: 완벽한 계획

### 📋 나의 완벽한 TODO 리스트

```
✅ 1. 완벽한 트리쉐이킹 (300KB 목표)
✅ 2. 완벽한 CSS 번들
✅ 3. 완벽한 Type 지원
✅ 4. 완벽한 배포 문서
✅ 5. 완벽한 자동 배포 시스템
```

**예상 기간**: 1-2일

---

## 슬라이드 4: 3주 후의 현실

### 💥 3주 후의 현실

**실제 결과**:

- 번들 사이즈: **20MB** (결과물의 66배)
- 타입 지원: 부분적
- 문서: 육성 + 슬랙
- 배포 시스템: ✅ (이건 성공!)

> **하지만... 돌아간다!** 🎉

---

# Part 0: 상황 설명

## "잘 구성했다고 생각했는데?"

---

## 슬라이드 5: 모노레포를 선택한 이유

### 왜 모노레포였나?

**배경**:

- 신규 프로젝트 + 디자인 시스템 동시 구현
- "어차피 언젠간 내보낼 거야"
- 추가 프로젝트도 들어오기로 결정

> 당시엔 완벽한 판단이라고 생각했다

---

## 슬라이드 6: 기술 스택 선택

### Mantine + Panda CSS

**선택 이유**:

- 리소스 부족한 상황
- Tailwind 문법에 대한 팀원들의 극혐 😅
- 모두가 동의한 현실적 선택

**패키지 이름**:

- 당당하게 원하는 대로 설정
- (나중에 scope 문제로 발목을 잡힐 줄 모르고...)

---

## 슬라이드 7: 모노레포 구조

### 현재 구조

```
monorepo/
├── design-system/          # 메인 디자인 시스템
└── packages/
    ├── @package/core       # HTTP 클라이언트, 상태 코드
    ├── @package/constants
    ├── @package/entities
    └── @package/service
```

**첫 번째 함정**:

- 디자인 시스템이 **내부 패키지 4개에 의존**
- 이유: GNB에 모든 공통 로직을 몽땅 때려넣음

---

## 슬라이드 8: peerDependency 선택

### 왜 peerDependency?

**dependencies로 넣으면?**

- 자동 설치되지만 → **중복 설치 문제**

**peerDependency로 넣으면?**

- "이 패키지들이 필요해요" 알림만
- 사용하는 쪽에서 직접 설치
- pnpm의 엄격한 의존성 관리와 잘 맞음

**결정**:

```json
{
  "peerDependencies": {
    "@package/core": "workspace:^",
    "@package/service": "workspace:^"
  }
}
```

---

## 슬라이드 9: 요구사항

### 해결해야 할 과제

**요구사항**:

1. ✅ NPM 패키지로 배포
2. ✅ 모노레포 외부 서비스에서 설치 가능
3. ✅ **Remix + Tailwind 환경**에서 **Mantine + Panda CSS** 돌리기

**도전 과제**:

- 모노레포 안에 있는 패키지를 밖으로
- 내부 패키지 4개 처리
- 서로 다른 CSS 프레임워크 조합

> "미리 잘 구성했다"고 생각했지만...

---

# Part 1: 빌드 지옥편

## "tsup, 너 이럴 거야?"

---

## 슬라이드 10: 빌드 도구 선정

### tsup을 선택한 이유

**찾고 있던 것**:

- 빠른 빌드 속도
- TypeScript 타입 자동 생성
- 최신 도구

**선택**: **tsup**

> "이거면 되겠다!"

---

## 슬라이드 11: SVG와의 첫 번째 조우

### SVGR 문제 발생

**우리 프로젝트**:

- SVGR로 SVG → 컴포넌트 변환 사용 중

**빌드 실행**:

```bash
Error: default export를 처리할 수 없습니다
```

**문제**:

```typescript
// SVGR이 생성한 코드
import * as React from 'react';
const Icon = () => <svg>...</svg>;
export default Icon; // ← tsup이 처리 못함!
```

---

## 슬라이드 12: SVGR 해결 시도

### 시도했던 방법들

**1️⃣ tsup 설정 조정**
→ 별 소용없음

**2️⃣ esbuild 플러그인 추가**
→ 복잡성만 증가

**3️⃣ 결국 타협**
→ TypeScript 컴파일 분리

---

## 슬라이드 13: 포기 #1 - 이중 빌드 시스템

### 💡 타협안: 빌드 시스템 이원화

```json
{
  "scripts": {
    "build": "tsup && tsc --emitDeclarationOnly"
  }
}
```

**역할 분리**:

- **tsup**: 번들링 담당
- **tsc**: 타입 정의 파일 생성 (별도)

**결과**:

- ✅ 빌드는 성공
- ❌ SVG 관련 타입 일부 누락
- ❌ 완벽하진 않지만 일단 돌아감

---

## 슬라이드 14: 의존성 처리

### 내부 패키지 빌드 제외

**문제**: 내부 패키지 4개를 어떻게 처리?

**해결**: `external`로 빌드에서 제외

```json
{
  "external": [
    "@package/core",
    "@package/constants",
    "@package/entities",
    "@package/service"
  ]
}
```

**이유**: `peerDependency`로 설정했으니 번들에 포함하면 안 됨

---

## 슬라이드 15: Panda codegen 라이프사이클

### prebuild 스크립트 추가

**Panda CSS 특성**:

- `panda codegen`으로 styled-system 생성 필요
- 빌드 전에 실행되어야 함

**해결**:

```json
{
  "scripts": {
    "prebuild": "panda codegen",
    "build": "tsup && tsc --emitDeclarationOnly"
  }
}
```

---

## 슬라이드 16: 빌드 완성

### 빌드 결과물

```
dist/
├── index.js          # CommonJS
├── index.mjs         # ES Modules
├── index.d.ts        # 타입 정의
├── index.js.map      # 소스맵
```

**새로 배운 것들**:

- CJS vs ESM 차이
- `.mjs`, `.d.ts` 의미
- `package.json`의 `exports`, `main`, `module`, `types`

**상태**: 빌드 완성! 하지만 모노레포 일부 깨짐... 😅

---

# Part 2: 로컬 테스트와 적용

## "CSS가 안 보여요"

---

## 슬라이드 17: pnpm pack 선택

### 빠른 로컬 테스트 환경 필요

**문제**:

- 배포 전에 로컬에서 테스트하고 싶음
- npm publish는 번거롭고 위험함

**해결책**: `pnpm pack`

```bash
# 디자인 시스템 패키지에서
pnpm pack
# → design-system-1.0.0.tgz 생성
```

**장점**:

- 실제 배포와 동일한 형태
- 복붙만 하면 됨 → **빠른 피드백 루프**

---

## 슬라이드 18: 로컬 설치

### 테스트 환경 구축

```bash
# 다른 서비스에서
pnpm install ../design-system/design-system-1.0.0.tgz
```

**피드백 루프**:

```
수정 → pack → 재설치 → 테스트 → 반복
```

> 이 방법 덕분에 빠르게 문제 발견 가능!

---

## 슬라이드 19: 첫 번째 적용

### "어라? CSS가 안 나와요?"

```typescript
import { Button } from '@our-org/design-system';
```

**결과**:

- ✅ 컴포넌트는 뜸
- ❌ **스타일이 전부 깨져있음**

> "왜지?"

---

## 슬라이드 20: Panda CSS 전달 문제

### CSS를 어떻게 전달할 것인가?

**시도 1: CSS 파일 생성해서 배포**

```bash
panda codegen --outfile styles.css
```

→ ❌ 필요한 클래스가 전부 생성되지 않음 (config 기반)

**시도 2: buildInfo로 런타임 생성**

→ ❌ 동작하지 않음 (클라이언트 설정 누락)

**시도 3: dist 폴더만 배포**

→ ❌ 런타임 에러 발생

---

## 슬라이드 21: 포기 #2 - 소스코드 통째로

### 💡 타협안: 소스코드를 통째로 넣기

```json
{
  "exports": {
    ".": "./src/index.ts", // dist가 아니라 src!
    "./components/*": "./src/components/*"
  }
}
```

**왜 이게 됐을까?**

- `styled-system` 폴더 전체 포함
- Panda CSS 함수를 런타임에 찾아갈 수 있음

**결과**: ✅ 드디어 스타일이 보인다!

---

## 슬라이드 22: 20MB 괴물의 탄생

### 패키지 사이즈 확인

**결과**: **20MB**

```
목표:  ▮ 300KB

현실:  ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮ 20MB
       ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮
       ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮

비율: 1 : 66
```

**포함된 것들**:

- 소스코드 전체 (`src/`)
- `styled-system` 전체
- `node_modules` 일부
- 모든 정적 자산 (fonts, svg...)

---

## 슬라이드 23: 포기 #3 - 300KB 목표

### 💡 타협: 일단 돌아가게 만들기

**현실**:

- 목표: 300KB
- 결과: 20MB (66배)

**하지만**:

- ✅ 로컬에서 완벽히 동작
- ✅ 타입도 제공됨
- ✅ 컴포넌트 사용 가능

**결정**: 최적화는 나중에, 일단 배포 시스템 완성하자!

> "완벽보다 실행"

---

# Part 3: 배포 자동화의 험난한 길

## npm scope와 무한 재귀

---

## 슬라이드 24: npm scope 문제 - 대참사

### 패키지 이름이 발목을 잡다

**GitHub npm에 배포 시도**:

```bash
Error: Package name must start with @organization/
```

**문제**: 당당하게 지었던 패키지 이름이 scope 규칙에 안 맞음

**해결 방법 고민**:

1. GitHub 조직 새로 만들기 → 복잡함
2. **패키지 이름 변경** → 🔥 선택!

---

## 슬라이드 26: 패키지 이름 변경 작업

### 모든 파일의 import 변경

```typescript
// Before
import { Button } from 'design-system';

// After
import { Button } from '@our-org/design-system';
```

**작업량**:

- 수십 개 파일에 걸친 import 수정
- peerDependency 설정 변경
- 빌드 설정 업데이트

> 대대적인 refactoring... 하지만 해야 한다

---

## 슬라이드 27: GitHub Actions 무한 재귀

### 배포 워크플로우 작성

```yaml
on:
  push:
    branches: [main]
```

**결과**: **무한 재귀 발생!**

```
1. Push → Actions 실행
2. Actions가 package.json 수정하고 커밋
3. 커밋 → 다시 Actions 실행
4. 무한 반복... 😱
```

> "미치겠다"

---

## 슬라이드 28: 무한 재귀 해결

### paths-ignore로 해결

```yaml
on:
  push:
    branches: [main]
    paths-ignore:
      - 'CHANGELOG.md'
      - 'package.json'
```

**원리**:

- 특정 파일 변경은 워크플로우 트리거 안 함
- Changeset이 수정하는 파일들을 무시

**결과**: ✅ 무한 재귀 해결!

---

## 슬라이드 29: GitHub Token 권한 이슈

### 배포 토큰 설정

**시도 1**: 개인 토큰

→ ❌ 권한 부족 에러

**시도 2**: GitHub 조직 토큰 발급

→ ✅ 성공!

(하지만 이것도 나중에 레거시가 됨...)

---

## 슬라이드 30: 기존 워크플로우와의 충돌

### CI/CD 워크플로우 간섭

**문제**:

```yaml
# 기존 워크플로우
- name: Build all packages
  run: pnpm build

# changeset 워크플로우
- name: Create Release PR
  run: pnpm changeset version
```

→ 두 워크플로우가 서로 간섭하며 예상치 못한 에러 속출

**해결**: 워크플로우 실행 순서 조정 + 조건부 실행으로 분리

---

## 슬라이드 31: 배포 자동화 완성!

### ✅ 드디어 성공!

**완성된 시스템**:

- PR 머지 → Changeset이 버전 업데이트
- main 브랜치 push → 자동으로 npm 배포
- CHANGELOG 자동 생성

**배운 것**:

- GitHub Actions 워크플로우 설계
- npm 배포 프로세스
- 버전 관리 자동화

> 이제 실제 서비스에 적용할 차례!

---

# Part 4: 실제 서비스 배포

## "불가능한 조합의 현실"

---

## 슬라이드 32: Remix + Tailwind 환경

### 실제 사용 환경의 특수성

**다른 팀의 환경**:

- **Remix** (React Router로 이전 중)
- **Tailwind CSS**
- **레거시 전역 CSS** (하드코딩 천지)

**우리 디자인 시스템**:

- **Mantine**
- **Panda CSS**

> 여기에 우리 시스템을 올려야 한다...

---

## 슬라이드 33: 전역 CSS 엉망

### 기존 CSS 상황 파악

```css
/* 기존 전역 CSS */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .button {
    background: red !important;
    padding: 10px !important;
  }
}

@layer base {
  div {
    box-sizing: border-box !important;
  }
}

/* layer 없이 직접 작성 */
.some-legacy-class {
  margin: 20px !important;
  color: blue !important;
}
```

**문제**: `!important` 도배 + Tailwind `@layer` 섞임

---

##슬라이드 35: 스타일이 전부 깨짐

### npm 설치 후 테스트

```bash
npm install @our-org/design-system
```

```typescript
import { Button } from '@our-org/design-system';
```

**결과**: **우리 디자인 시스템 스타일이 전부 덮어씌워짐**

> "역시나..."

---

## 슬라이드 36: Mantine + Tailwind 조합 지옥

### GitHub 이슈 검색

**발견한 것들**:

- "mantine + tailwind CSS 충돌"
- "클래스명 충돌 문제"
- "우선순위 꼬임"

**결론**: **많은 사람들이 이 조합을 포기**했다

**우리**: 그래도 해야 한다

---

## 슬라이드 37: CSS Layer 해결책

### @layer로 우선순위 제어

**CSS의 `@layer` 학습**:

1. **`@layer`로 우선순위 선언** - 먼저 선언된 layer가 낮은 우선순위
2. **`@import` with `layer()`** - 외부 CSS를 특정 layer에 배치

```css
/* 🎯 레이어 우선순위 설정 */
@layer reset, base, tokens, recipes, utilities,
       tailwind, mantine, panda-utilities;

/* Mantine CSS를 낮은 우선순위 layer에 */
@import '@mantine/core/styles.css' layer(mantine);

/* Tailwind도 별도 layer로 */
@layer tailwind {
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
}
```

---

## 슬라이드 38: 유일한 해결책

### 성공!

**결과**:

- ✅ `!important` 없이도 스타일 제어 가능
- ✅ Mantine, Tailwind, Panda CSS 공존
- ✅ 우선순위 디버깅 쉬워짐

**대신 감수한 것**:

- ❌ 기존 스타일 일부 깨짐
- ❌ 완벽한 호환은 불가능

**결론**: 현실적 타협

---

## 슬라이드 39: 드디어 완성!

### 우여곡절 끝에 성공 🎉

**완벽하진 않지만**:

- ✅ 디자인 시스템을 다른 팀이 사용 가능
- ✅ npm으로 배포되어 설치 가능
- ✅ 버전 관리 자동화
- ✅ Remix + Tailwind 환경에서 동작

**문제들은 산적**:

- 20MB 사이즈
- 타입 일부 누락
- 문서 미비

> **점진적으로 개선하면 된다**

---

# 에필로그: 완벽을 포기하고 배운 것들

## "별거 아니라고 하지 마세요!"

---

## 슬라이드 40: 포기한 것들 정리

### ❌ 포기한 것들

**포기 #1: 완벽한 타입 지원**

- tsup + tsc 이중 빌드
- SVG 타입 일부 누락
- 대안: 점진적 개선

**포기 #2: 완벽한 CSS 번들**

- 소스코드 통째로 배포
- styled-system 전체 포함
- 대안: buildInfo 재도전

**포기 #3: 300KB 목표**

- 20MB 괴물 패키지
- 정적 자산 전부 포함
- 대안: 트리쉐이킹 구조, 불필요한 파일 제거

**포기 #4: 완벽한 문서**

- 육성 + 슬랙
- 시간 부족
- 대안: 점진적 문서화

---

## 슬라이드 41: 그래도 성공한 것

### ✅ 성공한 것들

**성공 #1: 자동 배포 시스템**

- Changeset + GitHub Actions
- 버전 관리 자동화
- CHANGELOG 자동 생성

**성공 #2: 실제 사용 가능**

- npm 설치 가능
- 다른 팀에서 사용 중
- Remix + Tailwind 환경 호환

**성공 #3: 빠른 피드백**

- pnpm pack 로컬 테스트
- 문제 빠르게 발견
- 반복 개선 가능

---

## 슬라이드 42: 핵심 교훈

### 💡 배운 것들

**1️⃣ 완벽보다 실행**

> "일단 돌아가게 만들고, 그 다음에 개선"

**2️⃣ 현실적 타협**

> "팀 상황에 맞는 선택이 최선의 선택"

**3️⃣ 점진적 개선**

> "한 번에 완벽할 순 없다"

**가장 중요한 교훈**:

> **"별거 아닌 일은 없다"**

---

## 슬라이드 43: 기술적 학습

### 📚 새로 배운 기술들

**JavaScript 모듈 시스템**:

- CJS vs ESM 차이
- `.mjs`, `.mts`, `.cts` 의미
- `package.json` exports 필드

**CSS 우선순위 제어**:

- CSS `@layer` 문법
- `@import` with `layer()` 함수
- 우선순위 디버깅 방법

**패키지 배포**:

- peerDependencies vs dependencies
- npm scope 규칙
- 버전 관리 (시맨틱 버저닝)

**CI/CD 자동화**:

- GitHub Actions 워크플로우
- 무한 재귀 방지 (paths-ignore)
- 워크플로우 조건부 실행

---

## 슬라이드 44: 최적화 로드맵

### 🎯 앞으로 할 일 (점진적 개선)

**20MB → 300KB 최적화 계획**:

1. **트리쉐이킹 가능한 구조**

   - 개별 컴포넌트 import 지원
   - 사용하지 않는 코드 제거

2. **불필요한 자산 제거**

   - fonts, unused svg 제거
   - node_modules 정리

3. **SVG 별도 패키지화**

   - 타입 문제 해결
   - 선택적 설치 가능

4. **Panda buildInfo 재도전**
   - 정적 CSS 생성
   - 런타임 의존성 제거

> "완벽은 한 번에 오지 않는다"

---

## 슬라이드 45: 다음에는 이렇게

### 📝 체크리스트 (다음 삽질을 피하려면)

**사전 계획**:

- ☑ 패키지 이름 npm scope 규칙 확인
- ☑ CSS 프레임워크 조합 가능성 검증
- ☑ 빌드 도구 제약사항 사전 조사
- ☑ SVG 처리 방식 미리 결정

**개발 단계**:

- ☑ pnpm pack으로 로컬 테스트 환경 먼저 구축
- ☑ 빌드 결과물 확인 후 다음 단계 진행
- ☑ 내부 패키지 의존성 최소화

**적용 단계**:

- ☑ CSS Layer 우선순위 미리 설계
- ☑ 기존 CSS와의 충돌 지점 사전 파악
- ☑ 실제 환경과 유사한 테스트 환경 검증

**최적화**:

- ☑ 일단 돌아가게 만들기 우선
- ☑ 매 단계마다 측정 (번들 사이즈, 빌드 시간)
- ☑ 단계적으로 개선

---

## 슬라이드 46: 클로징

### 마지막으로

# "별거 아니라고 하지 마세요!" 🙏

**3주간의 삽질이 알려준 것**:

- 완벽한 해결책은 없다
- 팀 상황에 맞는 실용적 선택이 중요하다
- 일단 돌아가게 만들고, 점진적으로 개선한다

> 누군가는 이 발표를 보고
> "덕분에 삽질 안 하고 성공했어요!"
> 라고 말해주길 바랍니다.

**감사합니다.**

---

# 백업 슬라이드 (Q&A용)

---

## 기술 스택 상세

### 모노레포 구성

- Turborepo + pnpm workspace
- 디자인 시스템: Mantine + Panda CSS
- 빌드: tsup + tsc
- 배포: Changeset + GitHub Actions

### 사용 환경

- Remix + Tailwind CSS
- 레거시 전역 CSS

---

## 코드 예시: package.json

```json
{
  "name": "@our-org/design-system",
  "exports": {
    ".": "./src/index.ts",
    "./components/*": "./src/components/*"
  },
  "peerDependencies": {
    "@package/core": "workspace:^",
    "@package/service": "workspace:^"
  },
  "scripts": {
    "prebuild": "panda codegen",
    "build": "tsup && tsc --emitDeclarationOnly"
  }
}
```

---

## 코드 예시: CSS Layer

```css
/* 우선순위 선언 */
@layer reset, base, tokens, recipes, utilities,
       tailwind, mantine, panda-utilities;

/* Mantine을 낮은 우선순위로 */
@import '@mantine/core/styles.css' layer(mantine);

/* Tailwind도 별도 layer */
@layer tailwind {
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
}
```

---

## 코드 예시: GitHub Actions

```yaml
on:
  push:
    branches: [main]
    paths-ignore:
      - 'CHANGELOG.md'
      - 'package.json'

jobs:
  release:
    - name: Create Release PR
      run: pnpm changeset version
    - name: Publish to npm
      run: pnpm changeset publish
```

---

## 번들 사이즈 비교

```
목표:  ▮ 300KB

현실:  ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮ 20MB
       ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮
       ▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮▮

비율: 1 : 66
```

---

## pnpm pack 테스트 흐름

```bash
# 1. 디자인 시스템 패키지에서
pnpm pack
# → design-system-1.0.0.tgz 생성

# 2. 다른 서비스에서
pnpm install ../design-system/design-system-1.0.0.tgz

# 3. 빠른 피드백 루프
# 수정 → pack → 재설치 → 테스트
```

---

## CSS 충돌 Before/After

### Before (깨진 상태)

```css
/* 기존 CSS */
.button {
  background: red !important;
  padding: 10px !important;
}
/* 우리 스타일이 전부 무시됨 */
```

### After (@layer 적용)

```css
@layer legacy, design-system;

@layer legacy {
  .button {
    background: red;
  }
}

@layer design-system {
  .button {
    background: blue;
  }
  /* 이제 제대로 적용됨! */
}
```

---

## 참고 자료

- 원본 글: [링크]
- GitHub Repository: [링크]
- 질문/피드백: [이메일]

---
